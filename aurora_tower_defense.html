<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Aurora Tower Defense</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="icon" type="image/png" href="images/botbuiltarcade-icon-face.png">
  <style>
    :root {
      --gold: #FFD700;
      --teal: #5F9EA0;
      --ink: #0b0f12;
      --bg1: #0a0f14;
      --bg2: #0e1620;
      --topbar-h: 54px; /* measured on load/resize */
      --toolbar-h: 90px; /* measured on load/resize */
      --hud-offset: clamp(60px, 10vh, 140px); /* extra spacing below topbar for HUD visibility */
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(1200px 800px at 50% 10%, #102132 0%, #0b121a 45%, #070c12 100%);
      color: #F5F5DC;
      font-family: 'Press Start 2P', cursive;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .topbar {
      position: fixed; top: 0; left: 0; right: 0;
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px; padding: 10px 12px;
      background: rgba(0,0,0,0.45); border-bottom: 2px solid var(--gold);
      z-index: 20; backdrop-filter: blur(6px);
    }
    .back-btn {
      color: white; text-decoration: none;
      background: linear-gradient(45deg, var(--teal), #4682B4);
      border: 2px solid var(--gold); border-radius: 10px;
      padding: 8px 10px; font-size: 12px;
      box-shadow: 0 4px 12px rgba(95,158,160,0.4);
    }
    .title {
      font-size: 14px; letter-spacing: 1px; margin: 0 auto; text-align: center; flex: 1;
      background: linear-gradient(45deg, #FFD700, #FFA500);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .date-info { font-size: 10px; color: var(--teal); opacity: 0.9; }

    .game-wrap {
      position: fixed; left: 50%; top: var(--topbar-h); right: 0; bottom: var(--toolbar-h); transform: translateX(-50%);
      display: flex; align-items: center; justify-content: center; width: 100vw; height: calc(100vh - var(--topbar-h) - var(--toolbar-h));
      z-index: 10;
    }
    canvas { background: transparent; image-rendering: pixelated; touch-action: none; }

    .hud {
      position: absolute; top: calc(var(--topbar-h) + var(--hud-offset)); left: 50%; transform: translateX(-50%);
      color: var(--teal); text-shadow: 0 2px 6px rgba(0,0,0,0.6);
      font-size: 12px; z-index: 25; display: flex; gap: 16px;
      background: rgba(0,0,0,0.35); padding: 6px 10px; border-radius: 10px;
    }

    /* HUD alignment and wrapping control */
    .hud { align-items: center; flex-wrap: nowrap; white-space: nowrap; line-height: 1.2; }
    .hud .hud-item { display: inline-flex; align-items: baseline; gap: 6px; white-space: nowrap; }
    .hud .hud-emoji { font-size: 14px; line-height: 1; transform: translateY(1px); }
    .hud .hud-label { font-size: 12px; opacity: 0.95; }
    .hud .hud-value { font-variant-numeric: tabular-nums; }

    .toolbar {
      position: fixed; left: 50%; bottom: 14px; transform: translateX(-50%);
      display: flex; gap: 10px; z-index: 15; opacity: 0.98; flex-wrap: wrap;
    }
    .tool {
      min-width: 120px; display: flex; align-items: center; gap: 8px;
      background: linear-gradient(145deg, rgba(95,158,160,0.22), rgba(0,0,0,0.5));
      border: 2px solid var(--gold); border-radius: 12px; padding: 8px 10px;
      box-shadow: inset 0 4px 8px rgba(0,0,0,0.4), 0 6px 18px rgba(0,0,0,0.4);
      color: var(--gold); font-size: 12px; user-select: none;
    }
    .tool.selected { outline: 3px solid #7fffd4; }
    .tool img { width: 28px; height: 28px; }

    .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; flex-direction: column;
      background: radial-gradient(800px 400px at 50% 40%, rgba(0,0,0,0.6), rgba(0,0,0,0.9)); z-index: 18; text-align: center; padding: 24px; gap: 14px; }
    .overlay.show { display: flex; }
    .overlay h2 { margin: 0; color: var(--gold); font-size: 18px; }
    .overlay p { margin: 0; color: #d8f7ff; font-size: 12px; }
    .overlay .tap { color: var(--teal); font-size: 12px; opacity: 0.95; }

    .enemy-list { display: flex; flex-direction: column; gap: 10px; }
    .enemy-row { display: flex; align-items: center; gap: 12px; font-size: 12px; }
    .enemy-row img { width: 32px; height: 32px; }

    @media (min-width: 900px) {
      .toolbar { bottom: 20px; }
    }

    @media (max-width: 480px) {
      .back-btn { padding: 6px 8px; font-size: 11px; }
      .title { font-size: 12px; }
      .hud { font-size: 11px; gap: 10px; padding: 5px 8px; }
    }
  </style>
</head>
<body>
  <div class="topbar">
    <a class="back-btn" href="index.html">‚üµ Back to Home</a>
    <div class="title">
      Aurora Tower Defense<br>
      <span class="date-info">Created: August 10, 2025</span>
    </div>
    <button class="back-btn" id="enemyRefBtn">Enemies</button>
  </div>

  <div class="hud" id="hud">
    <span class="hud-item"><span class="hud-emoji" aria-hidden="true">üí∞</span><span id="coins" class="hud-value">0</span></span>
    <span class="hud-item"><span class="hud-emoji" aria-hidden="true">‚ù§Ô∏è</span><span id="lives" class="hud-value">0</span></span>
    <span class="hud-item"><span class="hud-emoji" aria-hidden="true">üåä</span><span class="hud-label">Wave</span><span id="wave" class="hud-value">1</span></span>
  </div>

  <div class="game-wrap">
    <canvas id="game"></canvas>
    <div class="overlay show" id="overlay">
      <h2>Defend the Aurora Core</h2>
      <p>Place towers on grass. Stop neon bugs from reaching the core.</p>
      <p class="tap">Tap to start ¬∑ Pinch zoom is disabled for precise taps</p>
    </div>
    <div class="overlay" id="enemyRef">
      <h2>Enemy Reference</h2>
      <div class="enemy-list">
        <div class="enemy-row"><img src="images/td_enemy_bug.svg" alt="Bug"><span>Bug - Balanced scout.</span></div>
        <div class="enemy-row"><img src="images/td_enemy_fast.svg" alt="Runner"><span>Runner - Quick but fragile.</span></div>
        <div class="enemy-row"><img src="images/td_enemy_armored.svg" alt="Armored"><span>Armored - Slow, heavily protected.</span></div>
      </div>
      <p class="tap">Tap to close</p>
    </div>
  </div>

  <div class="toolbar" id="toolbar">
    <div class="tool selected" data-type="basic" data-cost="25">
      <img src="images/td_tower_basic.svg" alt="basic">
      <div>Basic 25</div>
    </div>
    <div class="tool" data-type="slow" data-cost="35">
      <img src="images/td_tower_slow.svg" alt="slow">
      <div>Frost 35</div>
    </div>
    <div class="tool" data-type="pierce" data-cost="50">
      <img src="images/td_tower_pierce.svg" alt="pierce">
      <div>Pierce 50</div>
    </div>
  </div>

  <script>
    // Canvas and sizing
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const enemyRef = document.getElementById('enemyRef');
    const enemyRefBtn = document.getElementById('enemyRefBtn');
    const hudCoins = document.getElementById('coins');
    const hudLives = document.getElementById('lives');
    const hudWave = document.getElementById('wave');
    const topbarEl = document.querySelector('.topbar');
    const root = document.documentElement;
    const toolbar = document.getElementById('toolbar');

    // Leaderboard integration
    const GAME_ID = 'aurora-tower-defense';
    let gameOverHandled = false;

    function setTopbarHeight(){
      const h = Math.ceil(topbarEl.getBoundingClientRect().height);
      root.style.setProperty('--topbar-h', h + 'px');
    }
    // React to dynamic topbar height changes (e.g., font load, wrapping)
    if (typeof ResizeObserver !== 'undefined') {
      const ro = new ResizeObserver(() => { setTopbarHeight(); });
      ro.observe(topbarEl);
    }

    let COLS = 12, ROWS = 8, tile = 48; // computed on resize
    let pixelRatio = Math.max(1, Math.floor(window.devicePixelRatio || 1));

    // Assets
    const assets = {
      grass: 'images/td_tile_grass.svg',
      path: 'images/td_tile_path.svg',
      tower_basic: 'images/td_tower_basic.svg',
      tower_slow: 'images/td_tower_slow.svg',
      tower_pierce: 'images/td_tower_pierce.svg',
      enemy: 'images/td_enemy_bug.svg',
      enemy_fast: 'images/td_enemy_fast.svg',
      enemy_armored: 'images/td_enemy_armored.svg',
      bullet: 'images/td_bullet.svg',
      portal: 'images/td_portal.svg',
    };
    const Images = {};
    function loadImg(src) { return new Promise((res, rej) => { const i = new Image(); i.onload = () => res(i); i.onerror = rej; i.src = src; }); }

    // Path definition (grid points)
    const path = [
      {x:0,y:2}, {x:11,y:2}, {x:11,y:5}, {x:1,y:5}, {x:1,y:7}, {x:11,y:7}
    ];

    function lerp(a,b,t){ return a+(b-a)*t; }
    function gridToPx(gx, gy){ return { x: gx*tile + tile/2, y: gy*tile + tile/2 }; }

    // Game state
    let running = false;
    const state = {
      coins: 85,
      lives: 20,
      wave: 1,
      time: 0,
      kills: 0,
      leaks: 0,
    };

    const towers = []; // {gx, gy, type, cd}
    const bullets = []; // {x,y,vx,vy,spd, dmg, slow, slowDur, targetId, bonus}
    let enemies = []; // {id, x,y, seg, t, spd, hp, maxHp, slow, slowTimer}
    let nextEnemyId = 1;

    const TOWER_CONF = {
      basic: { range: 2.6, rof: 0.8, dmg: 16, spd: 420, cost: 25 },
      slow:  { range: 2.2, rof: 1.2, dmg: 8,  spd: 380, slow: 0.55, slowDur: 1.4, cost: 35 },
      pierce:{ range: 2.4, rof: 0.6, dmg: 32, spd: 450, cost: 50, bonus: { armored: 24 } },
    };

    const INITIAL_WAVE_SPEED = 50;
    const WAVE_SPEED_INCREMENT = 8;
    const MAX_WAVE_SPEED = 130;
    const ENEMY_CONF = { hp: 36, hpInc: 16 };
    const ENEMY_TYPES = {
      bug:    { img: 'enemy',         spdMul: 1,   hpMul: 1 },
      fast:   { img: 'enemy_fast',    spdMul: 1.8, hpMul: 0.6 },
      armored:{ img: 'enemy_armored', spdMul: 0.8, hpMul: 2.2 },
    };

    // UI selection
    let selectedTower = 'basic';
    toolbar.addEventListener('click', (e)=>{
      const item = e.target.closest('.tool'); if(!item) return;
      for(const el of toolbar.querySelectorAll('.tool')) el.classList.remove('selected');
      item.classList.add('selected');
      selectedTower = item.dataset.type;
    });

    enemyRefBtn.addEventListener('click', () => enemyRef.classList.add('show'));
    enemyRef.addEventListener('click', () => enemyRef.classList.remove('show'));

    function resize(){
      const availW = Math.min(window.innerWidth, 900);
      const topH = Math.ceil(topbarEl.getBoundingClientRect().height);
      const toolbarH = Math.ceil(toolbar.getBoundingClientRect().height || 0);
      const reserved = toolbarH + 40; // toolbar height + margin
      root.style.setProperty('--toolbar-h', reserved + 'px');
      const availH = window.innerHeight - topH - reserved;
      tile = Math.floor(Math.min(availW / COLS, availH / ROWS));
      const w = COLS*tile, h = ROWS*tile;
      canvas.style.width = w+'px'; canvas.style.height = h+'px';
      canvas.width = w*pixelRatio; canvas.height = h*pixelRatio;
      ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    }

    function segToPx(seg){
      const a = gridToPx(path[seg].x, path[seg].y), b = gridToPx(path[seg+1].x, path[seg+1].y);
      return { ax:a.x, ay:a.y, bx:b.x, by:b.y };
    }

    function addEnemy(type='bug'){
      const baseSpd = Math.min(INITIAL_WAVE_SPEED + (state.wave-1)*WAVE_SPEED_INCREMENT, MAX_WAVE_SPEED);
      const baseHp  = ENEMY_CONF.hp + (state.wave-1)*ENEMY_CONF.hpInc;
      const conf = ENEMY_TYPES[type] || ENEMY_TYPES.bug;
      const hp = baseHp * conf.hpMul;
      enemies.push({ id: nextEnemyId++, type, ...gridToPx(path[0].x, path[0].y), seg:0, t:0, spd: baseSpd * conf.spdMul, hp, maxHp: hp, slow:1, slowTimer:0 });
    }

    function spawnWave(){
      // Easier Wave 1, progressively harder later (quadratic term)
      const count = 4 + Math.floor(state.wave*1.2) + Math.floor((state.wave-1)*(state.wave-1)*0.3);
      let i = 0;
      // Track outstanding spawns so we don't advance the wave before enemies actually appear
      pendingSpawns = count;
      const iv = setInterval(()=>{
        const r = Math.random();
        let type = 'bug';
        if(state.wave > 4 && r < 0.2) type = 'armored';
        else if(state.wave > 2 && r < 0.5) type = 'fast';
        addEnemy(type);
        i++;
        pendingSpawns = Math.max(0, pendingSpawns - 1);
        if(i>=count){ clearInterval(iv); pendingSpawns = 0; }
      }, Math.max(200, 700 - state.wave*40));
    }

    function placeValid(gx, gy){
      // cannot place on path or outside or on existing tower
      if(gx<0||gy<0||gx>=COLS||gy>=ROWS) return false;
      // path occupancy check: compare with path segments nodes and along lines
      // We prevent placing on any tile center that matches path nodes or lies along straight path rows
      for(let i=0;i<path.length-1;i++){
        const a = path[i], b = path[i+1];
        if(a.y===b.y && gy===a.y && gx>=Math.min(a.x,b.x) && gx<=Math.max(a.x,b.x)) return false;
        if(a.x===b.x && gx===a.x && gy>=Math.min(a.y,b.y) && gy<=Math.max(a.y,b.y)) return false;
      }
      for(const t of towers){ if(t.gx===gx && t.gy===gy) return false; }
      return true;
    }

    function worldToGrid(x,y){ return { gx: Math.floor(x/tile), gy: Math.floor(y/tile) }; }

    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      const {gx, gy} = worldToGrid(x,y);
      if(!placeValid(gx,gy)) return;
      const conf = TOWER_CONF[selectedTower];
      const cost = conf.cost;
      if(state.coins < cost) return;
      state.coins -= cost;
      towers.push({ gx, gy, type: selectedTower, cd: 0 });
      updateHUD();
    }, {passive:true});

    canvas.addEventListener('touchstart', (e)=>{
      const t = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      const x = (t.clientX - rect.left);
      const y = (t.clientY - rect.top);
      const {gx, gy} = worldToGrid(x,y);
      if(!placeValid(gx,gy)) return;
      const conf = TOWER_CONF[selectedTower];
      const cost = conf.cost;
      if(state.coins < cost) return;
      state.coins -= cost; towers.push({ gx, gy, type: selectedTower, cd: 0 }); updateHUD();
      e.preventDefault();
    }, {passive:false});

    overlay.addEventListener('click', start);
    overlay.addEventListener('touchstart', (e)=>{ e.preventDefault(); start(); }, {passive:false});

    function updateHUD(){
      hudCoins.textContent = state.coins;
      hudLives.textContent = state.lives;
      hudWave.textContent = state.wave;
    }

    function aimAndShoot(){
      for(const t of towers){
        const conf = TOWER_CONF[t.type];
        t.cd = Math.max(0, t.cd - dt);
        if(t.cd>0) continue;
        // find nearest enemy within range (in tiles)
        const tx = t.gx*tile + tile/2, ty = t.gy*tile + tile/2;
        let best = null, bestD = 1e9;
        for(const e of enemies){
          const dx = e.x - tx, dy = e.y - ty; const d = Math.hypot(dx,dy);
          if(d < conf.range*tile && d < bestD){ best = e; bestD = d; }
        }
        if(best){
          const spd = conf.spd; const dx = best.x - tx, dy = best.y - ty; const d = Math.hypot(dx,dy)||1;
          bullets.push({ x: tx, y: ty, vx: dx/d, vy: dy/d, spd, dmg: conf.dmg, slow: conf.slow||0, slowDur: conf.slowDur||0, targetId: best.id, bonus: conf.bonus||{} });
          t.cd = 1/conf.rof; // cooldown seconds
        }
      }
    }

    function moveBullets(){
      for(const b of bullets){ b.x += b.vx*b.spd*dt; b.y += b.vy*b.spd*dt; }
      // hit check
      for(const b of bullets){
        let hit = null;
        for(const e of enemies){
          if(Math.hypot(e.x-b.x, e.y-b.y) < tile*0.45){ hit = e; break; }
        }
        if(hit){
          let extra = 0; if(b.bonus && b.bonus[hit.type]) extra = b.bonus[hit.type];
          hit.hp -= b.dmg + extra;
          if(b.slow){ hit.slow = Math.min(hit.slow, b.slow); hit.slowTimer = Math.max(hit.slowTimer, b.slowDur); }
          b.dead = true;
        }
      }
      // cleanup
      for(let i=bullets.length-1;i>=0;i--){ const b = bullets[i]; if(b.dead || b.x<-40||b.y<-40||b.x>COLS*tile+40||b.y>ROWS*tile+40) bullets.splice(i,1); }
    }

    function moveEnemies(){
      for(const e of enemies){
        if(e.slowTimer>0){ e.slowTimer -= dt; if(e.slowTimer<=0) e.slow = 1; }
        const speed = e.spd * e.slow;
        const s = segToPx(e.seg);
        const dx = s.bx - s.ax, dy = s.by - s.ay; const length = Math.hypot(dx,dy)||1;
        const nx = dx/length, ny = dy/length;
        e.x += nx * speed * dt; e.y += ny * speed * dt;
        // progress on segment
        const toB = Math.hypot(s.bx - e.x, s.by - e.y);
        if(toB < 4){ e.seg++; if(e.seg >= path.length-1){ // reached end
            e.reached = true; }
        }
      }
      // resolve reached
      for(let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        if(e.reached){
          state.lives -= 1;
          state.leaks += 1;
          enemies.splice(i,1);
          if(state.lives<=0) gameOver();
        }
        else if(e.hp<=0){ state.coins += 10; state.kills += 1; enemies.splice(i,1); }
      }
    }

    // Wave management
    let waveTimer = 0; let spawning = false; let pendingSpawns = 0;
    function updateWaves(){
      if(spawning){
        if(enemies.length===0 && pendingSpawns===0){
          spawning = false; state.wave++; waveTimer = 2.5;
        }
      } else if(enemies.length===0){
        // delay then start next
        waveTimer -= dt;
        if(waveTimer<=0){ spawning = true; spawnWave(); }
      }
    }

    function drawBackground(){
      if(!Images.grass || !Images.path || !Images.portal) return;
      // draw tiles
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          // is on path?
          let onPath = false;
          for(let i=0;i<path.length-1;i++){
            const a = path[i], b = path[i+1];
            if(a.y===b.y && y===a.y && x>=Math.min(a.x,b.x) && x<=Math.max(a.x,b.x)) { onPath=true; break; }
            if(a.x===b.x && x===a.x && y>=Math.min(a.y,b.y) && y<=Math.max(a.y,b.y)) { onPath=true; break; }
          }
          const img = onPath ? Images.path : Images.grass;
          ctx.drawImage(img, x*tile, y*tile, tile, tile);
        }
      }
      // portal at start
      const p0 = gridToPx(path[0].x, path[0].y);
      const s = tile*0.95; ctx.drawImage(Images.portal, p0.x - s/2, p0.y - s/2, s, s);
      // core at end (glowing circle)
      const p1 = gridToPx(path[path.length-1].x, path[path.length-1].y);
      const r = Math.max(12, tile*0.32);
      const grd = ctx.createRadialGradient(p1.x, p1.y, 3, p1.x, p1.y, r);
      grd.addColorStop(0, 'rgba(160,255,240,0.95)');
      grd.addColorStop(1, 'rgba(60,200,220,0.05)');
      ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(p1.x, p1.y, r, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#7fffd4'; ctx.lineWidth = 2; ctx.stroke();
    }

    function drawTowers(){
      for(const t of towers){
        const x = t.gx*tile, y = t.gy*tile;
        const img = Images['tower_'+t.type];
        ctx.drawImage(img, x, y, tile, tile);
      }
    }

    function drawEnemies(){
      for(const e of enemies){
        const s = tile*0.9;
        const imgKey = ENEMY_TYPES[e.type].img;
        ctx.drawImage(Images[imgKey], e.x - s/2, e.y - s/2, s, s);
        // HP bar
        const bw = Math.max(16, tile*0.8), bh = 5;
        const pct = Math.max(0, e.hp/e.maxHp);
        ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(e.x - bw/2, e.y - tile*0.6, bw, bh);
        ctx.fillStyle = '#7CFC00'; ctx.fillRect(e.x - bw/2, e.y - tile*0.6, bw*pct, bh);
        if(e.slow<1){ ctx.fillStyle = '#9be0ff'; ctx.fillRect(e.x - bw/2, e.y - tile*0.6 + bh, bw*pct, 2); }
      }
    }

    function drawBullets(){
      for(const b of bullets){ const s = tile*0.35; ctx.drawImage(Images.bullet, b.x - s/2, b.y - s/2, s, s); }
    }

    function draw(){
      if(!Images.grass) return;
      ctx.clearRect(0,0,canvas.width, canvas.height);
      drawBackground();
      drawTowers();
      drawEnemies();
      drawBullets();
    }

    let last = 0, dt = 0;
    function loop(ts){
      if(!running){ requestAnimationFrame(loop); return; }
      dt = Math.min(0.033, (ts - last)/1000 || 0.016); last = ts;
      state.time += dt;
      aimAndShoot();
      moveBullets();
      moveEnemies();
      updateWaves();
      updateHUD();
      draw();
      requestAnimationFrame(loop);
    }

    function gameOver(){
      running = false;
      overlay.querySelector('h2').textContent = 'Core Overrun';
      overlay.querySelector('p').textContent = 'Your defenses fell. Tap to try again.';
      overlay.classList.add('show');
      if (!gameOverHandled) { gameOverHandled = true; maybeSubmitLeaderboard().catch(console.error); }
    }

    function computeScore(){
      // Score: 100 per wave completed plus total kills
      // Minus leaked enemies and plus leftover coins
      return Math.max(0, (state.wave - 1) * 100 + state.kills + state.coins - state.leaks * 10);
    }

    async function maybeSubmitLeaderboard(){
      const score = computeScore();
      const dest = `leaderboard.html?gameId=${encodeURIComponent(GAME_ID)}`;
      try {
        const res = await fetch(`/api/leaderboard/rank?gameId=${encodeURIComponent(GAME_ID)}&score=${encodeURIComponent(score)}`, {
          headers: { 'Accept': 'application/json' }
        });
        if (res.ok) {
          const data = await res.json();
          const rank = Number(data?.rank);
          const qualifies = Number.isFinite(rank) && rank > 0 && rank <= 20;
          if (qualifies) {
            let name = prompt(`New High Score! You placed #${rank}. Enter your name (max 20 chars):`, '');
            if (name != null) {
              name = name.trim().replace(/[^\w \-'.!]/g, '').slice(0, 20);
              if (name) {
                try {
                  await fetch('/api/leaderboard/submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ gameId: GAME_ID, name, score })
                  });
                } catch {}
              }
            }
          }
        }
      } catch (e) {
        console.error(e);
      } finally {
        location.href = dest;
      }
    }

    async function start(){
      overlay.classList.remove('show');
      // load assets once
      if(!Images.grass){
        const entries = Object.entries(assets);
        for(const [k,src] of entries){ Images[k] = await loadImg(src); }
      }
      // reset state
      state.coins = 85; state.lives = 20; state.wave = 1; state.kills = 0; state.leaks = 0; enemies = []; bullets.length = 0; towers.length = 0; spawning=false; pendingSpawns=0; waveTimer=3.0; last=performance.now(); gameOverHandled = false;
      running = true;
      // First wave begins after a 3s prep time (handled by updateWaves)
    }

    window.addEventListener('resize', ()=>{ setTopbarHeight(); resize(); draw(); });
    setTopbarHeight();
    // Recompute after fonts load and with slight delays to catch late layout shifts
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => { setTopbarHeight(); resize(); draw(); });
    }
    setTimeout(() => { setTopbarHeight(); resize(); draw(); }, 250);
    setTimeout(() => { setTopbarHeight(); resize(); draw(); }, 1000);
    resize(); updateHUD(); requestAnimationFrame(loop);
  </script>
</body>
</html>
