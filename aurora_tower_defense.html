<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Aurora Tower Defense</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="icon" type="image/png" href="images/botbuiltarcade-icon-face.png">
  <style>
    :root {
      --gold: #FFD700;
      --teal: #5F9EA0;
      --ink: #0b0f12;
      --bg1: #0a0f14;
      --bg2: #0e1620;
      --topbar-h: 54px; /* measured on load/resize */
      --toolbar-h: 90px; /* measured on load/resize */
      --hud-offset: clamp(60px, 10vh, 140px); /* extra spacing below topbar for HUD visibility */
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(1200px 800px at 50% 10%, #102132 0%, #0b121a 45%, #070c12 100%);
      color: #F5F5DC;
      font-family: 'Press Start 2P', cursive;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .topbar {
      position: fixed; top: 0; left: 0; right: 0;
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px; padding: 10px 12px;
      background: rgba(0,0,0,0.45); border-bottom: 2px solid var(--gold);
      z-index: 20; backdrop-filter: blur(6px);
    }
    .back-btn {
      color: white; text-decoration: none;
      background: linear-gradient(45deg, var(--teal), #4682B4);
      border: 2px solid var(--gold); border-radius: 10px;
      padding: 8px 10px; font-size: 12px;
      box-shadow: 0 4px 12px rgba(95,158,160,0.4);
    }
    .title {
      font-size: 14px; letter-spacing: 1px; margin: 0 auto; text-align: center; flex: 1;
      background: linear-gradient(45deg, #FFD700, #FFA500);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .date-info { font-size: 10px; color: var(--teal); opacity: 0.9; }

    .game-wrap {
      position: fixed; left: 50%; top: var(--topbar-h); right: 0; bottom: var(--toolbar-h); transform: translateX(-50%);
      display: flex; align-items: center; justify-content: center; width: 100vw; height: calc(100vh - var(--topbar-h) - var(--toolbar-h));
      z-index: 10;
    }
    canvas { background: transparent; image-rendering: pixelated; touch-action: none; }

    .hud {
      position: absolute; top: calc(var(--topbar-h) + var(--hud-offset)); left: 50%; transform: translateX(-50%);
      color: var(--teal); text-shadow: 0 2px 6px rgba(0,0,0,0.6);
      font-size: 12px; z-index: 25; display: flex; gap: 16px;
      background: rgba(0,0,0,0.35); padding: 6px 10px; border-radius: 10px;
    }

    /* HUD alignment and wrapping control */
    .hud { align-items: center; flex-wrap: nowrap; white-space: nowrap; line-height: 1.2; }
    .hud .hud-item { display: inline-flex; align-items: baseline; gap: 6px; white-space: nowrap; }
    .hud .hud-emoji { font-size: 14px; line-height: 1; transform: translateY(1px); }
    .hud .hud-label { font-size: 12px; opacity: 0.95; }
    .hud .hud-value { font-variant-numeric: tabular-nums; }

    .toolbar {
      position: fixed; left: 50%; bottom: 14px; transform: translateX(-50%);
      display: flex; gap: 10px; z-index: 15; opacity: 0.98; flex-wrap: wrap;
    }
    .tool {
      min-width: 120px; display: flex; align-items: center; gap: 8px;
      background: linear-gradient(145deg, rgba(95,158,160,0.22), rgba(0,0,0,0.5));
      border: 2px solid var(--gold); border-radius: 12px; padding: 8px 10px;
      box-shadow: inset 0 4px 8px rgba(0,0,0,0.4), 0 6px 18px rgba(0,0,0,0.4);
      color: var(--gold); font-size: 12px; user-select: none;
    }
    .tool.selected { outline: 3px solid #7fffd4; }
    .tool img { width: 28px; height: 28px; }

    .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; flex-direction: column;
      background: radial-gradient(800px 400px at 50% 40%, rgba(0,0,0,0.6), rgba(0,0,0,0.9)); z-index: 18; text-align: center; padding: 24px; gap: 14px; }
    .overlay.show { display: flex; }
    .overlay h2 { margin: 0; color: var(--gold); font-size: 18px; }
    .overlay p { margin: 0; color: #d8f7ff; font-size: 12px; }
    .overlay .tap { color: var(--teal); font-size: 12px; opacity: 0.95; }

    .enemy-list { display: flex; flex-direction: column; gap: 10px; }
    .enemy-row { display: flex; align-items: center; gap: 12px; font-size: 12px; }
    .enemy-row img { width: 32px; height: 32px; }

    @media (min-width: 900px) {
      .toolbar { bottom: 20px; }
    }

    @media (max-width: 480px) {
      .back-btn { padding: 6px 8px; font-size: 11px; }
      .title { font-size: 12px; }
      .hud { font-size: 11px; gap: 10px; padding: 5px 8px; }
    }
    /* Nudge HUD upward on small screens to avoid overlapping playfield */
    @media (max-width: 600px) {
      :root { --hud-offset: clamp(0px, 0.5vh, 8px); }
      /* Prevent HUD from being cut off; widen and use 2-column layout */
      .hud {
        box-sizing: border-box;
        width: calc(100vw - env(safe-area-inset-left, 0px) - env(safe-area-inset-right, 0px) - 12px);
        padding-left: max(8px, env(safe-area-inset-left, 0px));
        padding-right: max(8px, env(safe-area-inset-right, 0px));
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        justify-content: center;
        align-items: center;
        justify-items: center;
        white-space: normal;
        gap: 8px 16px; /* row gap / column gap */
      }
      .hud .hud-item:last-child { grid-column: 1 / -1; justify-content: center; }
    }
    /* Generic scrollable modal panel inside overlays (for mobile-fit) */
    .overlay .panel {
      width: min(720px, 94vw);
      max-height: min(76vh, 84vh);
      overflow-y: auto;
      background: rgba(10,15,20,0.8);
      border: 2px solid var(--gold);
      border-radius: 12px;
      padding: 12px 14px;
      text-align: left;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    }
    .overlay .panel h3 { margin: 6px 0 8px; color: var(--gold); font-size: 14px; }
    .overlay .panel h4 { margin: 4px 0 6px; color: #7fffd4; font-size: 13px; }
    .overlay .panel p, .overlay .panel li, .overlay .panel small { color: #d8f7ff; font-size: 12px; line-height: 1.35; }
    .tower-cards { display: grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 600px) { .tower-cards { grid-template-columns: 1fr 1fr; } }
    .tower-card { border: 1px solid rgba(255,215,0,0.3); border-radius: 8px; padding: 8px; background: rgba(0,0,0,0.25); }
  </style>
</head>
<body>
  <div class="topbar">
    <a class="back-btn" href="index.html">‚üµ Back to Home</a>
    <div class="title">
      Aurora Tower Defense<br>
      <span class="date-info">Created: August 10, 2025</span>
    </div>
    <button class="back-btn" id="howToBtn">Instructions</button>
    <button class="back-btn" id="enemyRefBtn">Enemies</button>
  </div>

  <div class="hud" id="hud">
    <span class="hud-item"><span class="hud-emoji" aria-hidden="true">üí∞</span><span id="coins" class="hud-value">0</span></span>
    <span class="hud-item"><span class="hud-emoji" aria-hidden="true">‚ù§Ô∏è</span><span id="lives" class="hud-value">0</span></span>
    <span class="hud-item"><span class="hud-emoji" aria-hidden="true">üéöÔ∏è</span><span class="hud-label">Level</span><span id="level" class="hud-value">1</span></span>
    <span class="hud-item"><span class="hud-emoji" aria-hidden="true">üåä</span><span class="hud-label">Wave</span><span id="wave" class="hud-value">1</span></span>
    <span class="hud-item"><span class="hud-emoji" aria-hidden="true">‚≠ê</span><span class="hud-label">Score</span><span id="score" class="hud-value">0</span></span>
  </div>

  <div class="game-wrap">
    <canvas id="game"></canvas>
    <div class="overlay show" id="overlay">
      <h2>Defend the Aurora Core</h2>
      <p>Place towers on grass. Stop neon bugs from reaching the core.</p>
      <p class="tap">Tap to start ¬∑ Pinch zoom is disabled for precise taps</p>
    </div>
    <div class="overlay" id="enemyRef">
      <h2>Enemy Reference</h2>
      <div class="enemy-list">
        <div class="enemy-row"><img src="images/td_enemy_bug.svg" alt="Bug"><span>Bug - Balanced scout.</span></div>
        <div class="enemy-row"><img src="images/td_enemy_fast.svg" alt="Runner"><span>Runner - Quick but fragile.</span></div>
        <div class="enemy-row"><img src="images/td_enemy_armored.svg" alt="Armored"><span>Armored - Slow, heavily protected.</span></div>
        <div class="enemy-row"><img src="images/td_enemy_brute.svg" alt="Brute"><span>Brute - Titanic and tough.</span></div>
      </div>
      <p class="tap">Tap to close</p>
    </div>
    <div class="overlay" id="howTo">
      <h2>How to Play</h2>
      <div class="panel">
        <div id="howToContent"></div>
      </div>
      <p class="tap">Tap to close</p>
    </div>
  </div>

  <div class="toolbar" id="toolbar">
    <div class="tool selected" data-type="basic" data-cost="25">
      <img src="images/td_tower_basic.svg" alt="basic">
      <div>Basic 25</div>
    </div>
    <div class="tool" data-type="slow" data-cost="35">
      <img src="images/td_tower_slow.svg" alt="slow">
      <div>Frost 35</div>
    </div>
    <div class="tool" data-type="pierce" data-cost="50">
      <img src="images/td_tower_pierce.svg" alt="pierce">
      <div>Pierce 50</div>
    </div>
  </div>

  <script>
    // Canvas and sizing
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const enemyRef = document.getElementById('enemyRef');
    const enemyRefBtn = document.getElementById('enemyRefBtn');
    const howTo = document.getElementById('howTo');
    const howToBtn = document.getElementById('howToBtn');
    const howToContent = document.getElementById('howToContent');
    const gameWrap = document.querySelector('.game-wrap');
    const hudCoins = document.getElementById('coins');
    const hudLives = document.getElementById('lives');
    const hudWave = document.getElementById('wave');
    const hudLevel = document.getElementById('level');
    const hudScore = document.getElementById('score');
    const topbarEl = document.querySelector('.topbar');
    const root = document.documentElement;
    const toolbar = document.getElementById('toolbar');

    // Leaderboard integration
    const GAME_ID = 'aurora-tower-defense';
    let gameOverHandled = false;

    function setTopbarHeight(){
      const h = Math.ceil(topbarEl.getBoundingClientRect().height);
      root.style.setProperty('--topbar-h', h + 'px');
    }
    // React to dynamic topbar height changes (e.g., font load, wrapping)
    if (typeof ResizeObserver !== 'undefined') {
      const ro = new ResizeObserver(() => { setTopbarHeight(); });
      ro.observe(topbarEl);
    }

    let COLS = 12, ROWS = 8, tile = 48; // computed on resize
    let pixelRatio = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const WAVES_PER_LEVEL = 10;

    // Assets
    const assets = {
      grass: 'images/td_tile_grass.svg',
      path: 'images/td_tile_path.svg',
      tower_basic: 'images/td_tower_basic.svg',
      tower_slow: 'images/td_tower_slow.svg',
      tower_pierce: 'images/td_tower_pierce.svg',
      enemy: 'images/td_enemy_bug.svg',
      enemy_fast: 'images/td_enemy_fast.svg',
      enemy_armored: 'images/td_enemy_armored.svg',
      enemy_brute: 'images/td_enemy_brute.svg',
      bullet: 'images/td_bullet.svg',
      portal: 'images/td_portal.svg',
    };
    const Images = {};
    function loadImg(src) { return new Promise((res, rej) => { const i = new Image(); i.onload = () => res(i); i.onerror = rej; i.src = src; }); }

    // Path definitions (grid points)
    const MAPS = [
      // Level 1
      [ {x:0,y:2}, {x:11,y:2}, {x:11,y:5}, {x:1,y:5}, {x:1,y:7}, {x:11,y:7} ],
      // Level 2 - new longer layout for easier defense
      [ {x:0,y:3}, {x:4,y:3}, {x:4,y:1}, {x:8,y:1}, {x:8,y:6}, {x:2,y:6}, {x:2,y:7}, {x:11,y:7} ],
      // Level 3 - zigzag with mid-map detour
      [ {x:0,y:4}, {x:3,y:4}, {x:3,y:2}, {x:9,y:2}, {x:9,y:5}, {x:5,y:5}, {x:5,y:7}, {x:11,y:7} ]
    ];
    let path = MAPS[0];
    function chooseMap(level){
      path = MAPS[(level-1) % MAPS.length];
    }

    function lerp(a,b,t){ return a+(b-a)*t; }
    function gridToPx(gx, gy){ return { x: gx*tile + tile/2, y: gy*tile + tile/2 }; }

    // Game state
    let running = false;
    const state = {
      level: 1,
      coins: 85,
      lives: 20,
      wave: 1,
      time: 0,
      kills: 0,
      leaks: 0,
    };

    const towers = []; // {gx, gy, type, cd, lvl}
    const bullets = []; // {x,y,vx,vy,spd, dmg, slow, slowDur, targetId, bonus}
    let enemies = []; // {id, x,y, seg, t, spd, hp, maxHp, slow, slowTimer}
    let nextEnemyId = 1;

    const TOWER_CONF = {
      basic: { range: 2.6, rof: 0.8, dmg: 16, spd: 420, cost: 25 },
      slow:  { range: 2.2, rof: 1.2, dmg: 8,  spd: 380, slow: 0.55, slowDur: 1.4, cost: 35 },
      pierce:{ range: 2.4, rof: 0.6, dmg: 32, spd: 450, cost: 50, bonus: { armored: 24 } },
    };

    function towerStats(t){
      const base = TOWER_CONF[t.type];
      const lvl = t.lvl || 1;
      const dmg = base.dmg * (1 + 0.5*(lvl-1));
      const range = base.range * (1 + 0.15*(lvl-1));
      const rof = base.rof * (1 + 0.15*(lvl-1));
      return { ...base, dmg, range, rof };
    }

    const INITIAL_WAVE_SPEED = 50;
    const WAVE_SPEED_INCREMENT = 4;
    const MAX_WAVE_SPEED = 130;
    const ENEMY_CONF = { hp: 36, hpInc: 12 };
    const ENEMY_TYPES = {
      bug:    { img: 'enemy',         spdMul: 1,   hpMul: 1 },
      fast:   { img: 'enemy_fast',    spdMul: 1.8, hpMul: 0.6 },
      armored:{ img: 'enemy_armored', spdMul: 0.8, hpMul: 2.2 },
      brute:  { img: 'enemy_brute',   spdMul: 0.6, hpMul: 4 },
    };

    // UI selection
    let selectedTower = 'basic';
    toolbar.addEventListener('click', (e)=>{
      const item = e.target.closest('.tool'); if(!item) return;
      for(const el of toolbar.querySelectorAll('.tool')) el.classList.remove('selected');
      item.classList.add('selected');
      selectedTower = item.dataset.type;
    });

    function setOverlayMode(on){ if(gameWrap){ gameWrap.style.zIndex = on ? '30' : ''; } }
    // Pause/resume helpers when opening/closing info panels
    let wasRunningBeforeModal = false;
    function openPanel(panelEl){
      // Capture state only when transitioning from zero info panels open to at least one
      const infoOpenBefore = enemyRef.classList.contains('show') || howTo.classList.contains('show');
      if(!infoOpenBefore){
        wasRunningBeforeModal = running;
        running = false; // pause game loop
      }
      setOverlayMode(true);
      panelEl.classList.add('show');
    }
    function closePanel(panelEl){
      panelEl.classList.remove('show');
      const anyOpen = overlay.classList.contains('show') || enemyRef.classList.contains('show') || howTo.classList.contains('show');
      if(!anyOpen){
        setOverlayMode(false);
        if(wasRunningBeforeModal){
          running = true; // resume only if it was running previously
        }
      }
    }
    enemyRefBtn.addEventListener('click', () => { openPanel(enemyRef); });
    enemyRef.addEventListener('click', () => { closePanel(enemyRef); });
    howToBtn.addEventListener('click', () => { buildHowTo(); openPanel(howTo); });
    howTo.addEventListener('click', () => { closePanel(howTo); });
    // Ensure initial overlay covers HUD on load
    if (overlay.classList.contains('show') || enemyRef.classList.contains('show') || howTo.classList.contains('show')) {
      setOverlayMode(true);
    }

    function buildHowTo(){
      function dmgAt(base, lvl){ return Math.round(base * (1 + 0.5 * (lvl - 1))); }
      function rofAt(base, lvl){ return +(base * (1 + 0.15 * (lvl - 1))).toFixed(2); }
      function towerCard(key, display){
        const conf = TOWER_CONF[key];
        const d1 = dmgAt(conf.dmg,1), d2 = dmgAt(conf.dmg,2), d3 = dmgAt(conf.dmg,3);
        const r1 = rofAt(conf.rof,1), r2 = rofAt(conf.rof,2), r3 = rofAt(conf.rof,3);
        let extra = '';
        if(conf.slow){ const pct = Math.round((1 - conf.slow) * 100); extra += `<li>Slows: ${pct}% for ${conf.slowDur.toFixed(1)}s</li>`; }
        if(conf.bonus){ const parts = Object.entries(conf.bonus).map(([k,v])=>`+${v} vs ${k}`); extra += `<li>Bonus: ${parts.join(', ')}</li>`; }
        return `
          <div class="tower-card">
            <h4>${display} (Cost ${conf.cost})</h4>
            <ul>
              <li>Damage/shot: ${d1} / ${d2} / ${d3}</li>
              <li>Rate of fire: ${r1} / ${r2} / ${r3} shots/s</li>
              ${extra}
            </ul>
          </div>`;
      }
      const html = `
        <p>Place towers on grass. Tap an existing tower to upgrade (max L3). Earn coins from kills. Don't let enemies reach the core.</p>
        <div class="tower-cards">
          ${towerCard('basic','Basic')}
          ${towerCard('slow','Frost')}
          ${towerCard('pierce','Pierce')}
        </div>
      `;
      howToContent.innerHTML = html;
    }

    function resize(){
      const availW = Math.min(window.innerWidth, 900);
      const topH = Math.ceil(topbarEl.getBoundingClientRect().height);
      const toolbarH = Math.ceil(toolbar.getBoundingClientRect().height || 0);
      const reserved = toolbarH; // toolbar height
      root.style.setProperty('--toolbar-h', reserved + 'px');
      const availH = window.innerHeight - topH - reserved;
      tile = Math.floor(Math.min(availW / COLS, availH / ROWS));
      const w = COLS*tile, h = ROWS*tile;
      canvas.style.width = w+'px'; canvas.style.height = h+'px';
      canvas.width = w*pixelRatio; canvas.height = h*pixelRatio;
      ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    }

    function segToPx(seg){
      const a = gridToPx(path[seg].x, path[seg].y), b = gridToPx(path[seg+1].x, path[seg+1].y);
      return { ax:a.x, ay:a.y, bx:b.x, by:b.y };
    }

    function addEnemy(type='bug'){
      const waveNumber = state.wave;
      const level = state.level;
      const hardWave = waveNumber >= 9;
      const baseSpd = Math.min(
        INITIAL_WAVE_SPEED + (waveNumber-1)*WAVE_SPEED_INCREMENT + (level-1)*10,
        MAX_WAVE_SPEED
      ) * (hardWave ? 1.1 : 1);
      const baseHp  = (ENEMY_CONF.hp + (waveNumber-1)*ENEMY_CONF.hpInc + (level-1)*50) * (hardWave ? 1.2 : 1);
      const conf = ENEMY_TYPES[type] || ENEMY_TYPES.bug;
      const hp = baseHp * conf.hpMul;
      enemies.push({ id: nextEnemyId++, type, ...gridToPx(path[0].x, path[0].y), seg:0, t:0, spd: baseSpd * conf.spdMul, hp, maxHp: hp, slow:1, slowTimer:0 });
    }

    function spawnWave(){
      const waveNumber = state.wave;
      const level = state.level;
      const hardWave = waveNumber >= 9;
      // Easier Wave 1, progressively harder later (quadratic term)
      let count = 4 + Math.floor(((level-1)*2 + waveNumber)*1.2) + Math.floor((waveNumber-1)*(waveNumber-1)*0.3);
      if(hardWave) count = Math.floor(count * 1.25);
      let i = 0;
      // Track outstanding spawns so we don't advance the wave before enemies actually appear
      pendingSpawns = count;
      const baseInterval = Math.max(250, 700 - (waveNumber-1)*40 + (level-1)*120);
      const iv = setInterval(()=>{
        const r = Math.random();
        let type = 'bug';
        if(level > 1 && r < 0.15) type = 'brute';
        else if(hardWave && r < 0.3) type = 'armored';
        else if(waveNumber + (level-1)*WAVES_PER_LEVEL > 8 && r < 0.2) type = 'armored';
        else if(waveNumber + (level-1)*WAVES_PER_LEVEL > 4 && r < 0.5) type = 'fast';
        addEnemy(type);
        i++;
        pendingSpawns = Math.max(0, pendingSpawns - 1);
        if(i>=count){ clearInterval(iv); pendingSpawns = 0; }
      }, hardWave ? Math.max(200, baseInterval * 0.8) : baseInterval);
    }

    function placeValid(gx, gy){
      // cannot place on path or outside or on existing tower
      if(gx<0||gy<0||gx>=COLS||gy>=ROWS) return false;
      // path occupancy check: compare with path segments nodes and along lines
      // We prevent placing on any tile center that matches path nodes or lies along straight path rows
      for(let i=0;i<path.length-1;i++){
        const a = path[i], b = path[i+1];
        if(a.y===b.y && gy===a.y && gx>=Math.min(a.x,b.x) && gx<=Math.max(a.x,b.x)) return false;
        if(a.x===b.x && gx===a.x && gy>=Math.min(a.y,b.y) && gy<=Math.max(a.y,b.y)) return false;
      }
      for(const t of towers){ if(t.gx===gx && t.gy===gy) return false; }
      return true;
    }

    function worldToGrid(x,y){ return { gx: Math.floor(x/tile), gy: Math.floor(y/tile) }; }

    canvas.addEventListener('click', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      const {gx, gy} = worldToGrid(x,y);
      const existing = towers.find(t => t.gx === gx && t.gy === gy);
      if(existing){
        const lvl = existing.lvl || 1;
        if(lvl >= 3) return;
        const cost = Math.round(TOWER_CONF[existing.type].cost * lvl);
        if(state.coins < cost) return;
        state.coins -= cost;
        existing.lvl = lvl + 1;
        updateHUD();
        return;
      }
      if(!placeValid(gx,gy)) return;
      const conf = TOWER_CONF[selectedTower];
      const cost = conf.cost;
      if(state.coins < cost) return;
      state.coins -= cost;
      towers.push({ gx, gy, type: selectedTower, cd: 0, lvl: 1 });
      updateHUD();
    }, {passive:true});

    canvas.addEventListener('touchstart', (e)=>{
      const t = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      const x = (t.clientX - rect.left);
      const y = (t.clientY - rect.top);
      const {gx, gy} = worldToGrid(x,y);
      const existing = towers.find(tt => tt.gx === gx && tt.gy === gy);
      if(existing){
        const lvl = existing.lvl || 1;
        if(lvl >= 3) return;
        const cost = Math.round(TOWER_CONF[existing.type].cost * lvl);
        if(state.coins < cost) return;
        state.coins -= cost;
        existing.lvl = lvl + 1;
        updateHUD();
        e.preventDefault();
        return;
      }
      if(!placeValid(gx,gy)) return;
      const conf = TOWER_CONF[selectedTower];
      const cost = conf.cost;
      if(state.coins < cost) return;
      state.coins -= cost; towers.push({ gx, gy, type: selectedTower, cd: 0, lvl: 1 }); updateHUD();
      e.preventDefault();
    }, {passive:false});

    overlay.addEventListener('click', start);
    overlay.addEventListener('touchstart', (e)=>{ e.preventDefault(); start(); }, {passive:false});

    function updateHUD(){
      hudCoins.textContent = state.coins;
      hudLives.textContent = state.lives;
      hudLevel.textContent = state.level;
      hudWave.textContent = state.wave;
      hudScore.textContent = computeScore();
    }

    function aimAndShoot(){
      for(const t of towers){
        const conf = towerStats(t);
        t.cd = Math.max(0, t.cd - dt);
        if(t.cd>0) continue;
        // find nearest enemy within range (in tiles)
        const tx = t.gx*tile + tile/2, ty = t.gy*tile + tile/2;
        let best = null, bestD = 1e9;
        for(const e of enemies){
          const dx = e.x - tx, dy = e.y - ty; const d = Math.hypot(dx,dy);
          if(d < conf.range*tile && d < bestD){ best = e; bestD = d; }
        }
        if(best){
          const spd = conf.spd; const dx = best.x - tx, dy = best.y - ty; const d = Math.hypot(dx,dy)||1;
          bullets.push({ x: tx, y: ty, vx: dx/d, vy: dy/d, spd, dmg: conf.dmg, slow: conf.slow||0, slowDur: conf.slowDur||0, targetId: best.id, bonus: conf.bonus||{} });
          t.cd = 1/conf.rof; // cooldown seconds
        }
      }
    }

    function moveBullets(){
      for(const b of bullets){ b.x += b.vx*b.spd*dt; b.y += b.vy*b.spd*dt; }
      // hit check
      for(const b of bullets){
        let hit = null;
        for(const e of enemies){
          if(Math.hypot(e.x-b.x, e.y-b.y) < tile*0.45){ hit = e; break; }
        }
        if(hit){
          let extra = 0; if(b.bonus && b.bonus[hit.type]) extra = b.bonus[hit.type];
          hit.hp -= b.dmg + extra;
          if(b.slow){ hit.slow = Math.min(hit.slow, b.slow); hit.slowTimer = Math.max(hit.slowTimer, b.slowDur); }
          b.dead = true;
        }
      }
      // cleanup
      for(let i=bullets.length-1;i>=0;i--){ const b = bullets[i]; if(b.dead || b.x<-40||b.y<-40||b.x>COLS*tile+40||b.y>ROWS*tile+40) bullets.splice(i,1); }
    }

    function moveEnemies(){
      for(const e of enemies){
        if(e.slowTimer>0){ e.slowTimer -= dt; if(e.slowTimer<=0) e.slow = 1; }
        let remaining = e.spd * e.slow * dt;
        while(remaining>0 && !e.reached){
          const s = segToPx(e.seg);
          const dx = s.bx - s.ax, dy = s.by - s.ay; const length = Math.hypot(dx,dy)||1;
          const dist = length * (1 - e.t);
          if(remaining >= dist){
            e.x = s.bx; e.y = s.by;
            remaining -= dist;
            e.seg++; e.t = 0;
            if(e.seg >= path.length-1){ e.reached = true; }
          } else {
            e.t += remaining/length;
            e.x = s.ax + dx*e.t; e.y = s.ay + dy*e.t;
            remaining = 0;
          }
        }
        // fail-safe for any stray enemies leaving bounds
        if(e.x<-40||e.y<-40||e.x>COLS*tile+40||e.y>ROWS*tile+40){ e.reached = true; }
      }
      // resolve reached and dead enemies
      for(let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        if(e.reached){
          state.lives -= 1;
          state.leaks += 1;
          enemies.splice(i,1);
          if(state.lives<=0) gameOver();
        }
        else if(e.hp<=0){ state.coins += 10; state.kills += 1; enemies.splice(i,1); }
      }
    }

    // Wave management
    let waveTimer = 0; let spawning = false; let pendingSpawns = 0;
    function updateWaves(){
      if(spawning){
        if(enemies.length===0 && pendingSpawns===0){
          spawning = false; state.wave++;
          if(state.wave > WAVES_PER_LEVEL){ nextLevel(); return; }
          waveTimer = 2.5;
        }
      } else if(enemies.length===0){
        if(state.wave > WAVES_PER_LEVEL) return;
        // delay then start next
        waveTimer -= dt;
        if(waveTimer<=0){ spawning = true; spawnWave(); }
      }
    }

    function drawBackground(){
      if(!Images.grass || !Images.path || !Images.portal) return;
      // draw tiles
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          // is on path?
          let onPath = false;
          for(let i=0;i<path.length-1;i++){
            const a = path[i], b = path[i+1];
            if(a.y===b.y && y===a.y && x>=Math.min(a.x,b.x) && x<=Math.max(a.x,b.x)) { onPath=true; break; }
            if(a.x===b.x && x===a.x && y>=Math.min(a.y,b.y) && y<=Math.max(a.y,b.y)) { onPath=true; break; }
          }
          const img = onPath ? Images.path : Images.grass;
          ctx.drawImage(img, x*tile, y*tile, tile, tile);
        }
      }
      // portal at start
      const p0 = gridToPx(path[0].x, path[0].y);
      const s = tile*0.95; ctx.drawImage(Images.portal, p0.x - s/2, p0.y - s/2, s, s);
      // core at end (glowing circle)
      const p1 = gridToPx(path[path.length-1].x, path[path.length-1].y);
      const r = Math.max(12, tile*0.32);
      const grd = ctx.createRadialGradient(p1.x, p1.y, 3, p1.x, p1.y, r);
      grd.addColorStop(0, 'rgba(160,255,240,0.95)');
      grd.addColorStop(1, 'rgba(60,200,220,0.05)');
      ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(p1.x, p1.y, r, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#7fffd4'; ctx.lineWidth = 2; ctx.stroke();
    }

    function drawTowers(){
      for(const t of towers){
        const x = t.gx*tile, y = t.gy*tile;
        const img = Images['tower_'+t.type];
        ctx.drawImage(img, x, y, tile, tile);
        if((t.lvl||1) > 1){
          ctx.save();
          ctx.fillStyle = '#FFD700';
          ctx.font = Math.max(10, tile*0.4)+"px 'Press Start 2P'";
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(t.lvl, x + tile/2, y + tile - 4);
          ctx.restore();
        }
      }
    }

    function drawEnemies(){
      for(const e of enemies){
        const s = tile*0.9;
        const imgKey = ENEMY_TYPES[e.type].img;
        ctx.drawImage(Images[imgKey], e.x - s/2, e.y - s/2, s, s);
        // HP bar
        const bw = Math.max(16, tile*0.8), bh = 5;
        const pct = Math.max(0, e.hp/e.maxHp);
        ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(e.x - bw/2, e.y - tile*0.6, bw, bh);
        ctx.fillStyle = '#7CFC00'; ctx.fillRect(e.x - bw/2, e.y - tile*0.6, bw*pct, bh);
        if(e.slow<1){ ctx.fillStyle = '#9be0ff'; ctx.fillRect(e.x - bw/2, e.y - tile*0.6 + bh, bw*pct, 2); }
      }
    }

    function drawBullets(){
      for(const b of bullets){ const s = tile*0.35; ctx.drawImage(Images.bullet, b.x - s/2, b.y - s/2, s, s); }
    }

    function draw(){
      if(!Images.grass) return;
      ctx.clearRect(0,0,canvas.width, canvas.height);
      drawBackground();
      drawTowers();
      drawEnemies();
      drawBullets();
    }

    let last = 0, dt = 0;
    function loop(ts){
      if(!running){ requestAnimationFrame(loop); return; }
      dt = Math.min(0.033, (ts - last)/1000 || 0.016); last = ts;
      state.time += dt;
      aimAndShoot();
      moveBullets();
      moveEnemies();
      updateWaves();
      updateHUD();
      draw();
      requestAnimationFrame(loop);
    }

    function gameOver(){
      running = false;
      overlay.querySelector('h2').textContent = 'Core Overrun';
      overlay.querySelector('p').textContent = 'Your defenses fell. Tap to try again.';
      setOverlayMode(true);
      overlay.classList.add('show');
      if (!gameOverHandled) { gameOverHandled = true; maybeSubmitLeaderboard().catch(console.error); }
    }

    function victory(){
      running = false;
      overlay.querySelector('h2').textContent = 'Aurora Defended!';
      overlay.querySelector('p').textContent = 'All waves cleared. Tap to play again.';
      setOverlayMode(true);
      overlay.classList.add('show');
      if (!gameOverHandled) { gameOverHandled = true; maybeSubmitLeaderboard().catch(console.error); }
    }

    function nextLevel(){
      const completed = state.level;
      // If all maps are completed, end the game with victory
      if (completed >= MAPS.length) {
        victory();
        return;
      }
      state.level++;
      running = false;
      overlay.querySelector('h2').textContent = `Level ${completed} Complete`;
      overlay.querySelector('p').textContent = `Tap to start Level ${state.level}`;
      setOverlayMode(true);
      overlay.classList.add('show');
    }

    function computeScore(){
      // Score: 100 per wave completed plus total kills
      // Minus leaked enemies and plus leftover coins
      const totalWaves = (state.level-1)*WAVES_PER_LEVEL + (state.wave - 1);
      return Math.max(0, totalWaves * 100 + state.kills + state.coins - state.leaks * 10);
    }

    async function maybeSubmitLeaderboard(){
      const score = computeScore();
      let dest = `leaderboard.html?gameId=${encodeURIComponent(GAME_ID)}`;
      try {
        const res = await fetch(`/api/leaderboard/rank?gameId=${encodeURIComponent(GAME_ID)}&score=${encodeURIComponent(score)}`, {
          headers: { 'Accept': 'application/json' }
        });
        if (res.ok) {
          const data = await res.json();
          const rank = Number(data?.rank);
          const qualifies = Number.isFinite(rank) && rank > 0 && rank <= 20;
          if (qualifies) {
            let name = prompt(`New High Score! You placed #${rank}. Enter your name (max 20 chars):`, '');
            if (name != null) {
              name = name.trim().replace(/[^\w \-'.!]/g, '').slice(0, 20);
              if (name) {
                let submitted = false;
                try {
                  await fetch('/api/leaderboard/submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ gameId: GAME_ID, name, score })
                  });
                  submitted = true;
                } catch {}
                if (submitted) {
                  dest += `&highlightRank=${encodeURIComponent(rank)}`;
                }
              }
            }
          }
        }
      } catch (e) {
        console.error(e);
      } finally {
        location.href = dest;
      }
    }

    async function start(){
      overlay.classList.remove('show');
      setOverlayMode(false);
      // load assets once
      if(!Images.grass){
        const entries = Object.entries(assets);
        for(const [k,src] of entries){ Images[k] = await loadImg(src); }
      }
      chooseMap(state.level);
      // reset state (except level)
      state.coins = 85 + (state.level-1)*40; state.lives = 20; state.wave = 1; state.kills = 0; state.leaks = 0; enemies = []; bullets.length = 0; towers.length = 0; spawning=false; pendingSpawns=0; waveTimer=3.0; last=performance.now(); gameOverHandled = false;
      running = true;
      // First wave begins after a 3s prep time (handled by updateWaves)
    }

    window.addEventListener('resize', ()=>{ setTopbarHeight(); resize(); draw(); });
    setTopbarHeight();
    // Recompute after fonts load and with slight delays to catch late layout shifts
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => { setTopbarHeight(); resize(); draw(); });
    }
    setTimeout(() => { setTopbarHeight(); resize(); draw(); }, 250);
    setTimeout(() => { setTopbarHeight(); resize(); draw(); }, 1000);
    resize(); updateHUD(); requestAnimationFrame(loop);
  </script>
</body>
</html>
