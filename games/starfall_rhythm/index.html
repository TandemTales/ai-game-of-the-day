<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Starfall Rhythm</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="icon" type="image/png" href="../../images/botbuiltarcade-icon-face.png">
  <style>
    :root {
      --gold: #FFD700;
      --teal: #5F9EA0;
      --bg1: #0a0f14;
      --bg2: #0e1620;
      --ink: #F5F5DC;
      --topbar-h: 56px;
    }
    html, body { margin:0; height:100%; background: radial-gradient(1200px 800px at 50% 10%, #101826 0%, #0b121a 45%, #070c12 100%); color: var(--ink); font-family: 'Press Start 2P', cursive; overflow:hidden; }
    .topbar { position: fixed; inset: 0 0 auto 0; display:flex; align-items:center; gap:12px; padding:10px 12px; background: rgba(0,0,0,0.45); border-bottom:2px solid var(--gold); z-index: 20; backdrop-filter: blur(6px); }
    .back-btn { color:#fff; text-decoration:none; background: linear-gradient(45deg, var(--teal), #4682B4); border:2px solid var(--gold); border-radius:10px; padding:8px 10px; font-size:12px; box-shadow: 0 4px 12px rgba(95,158,160,0.4); }
    .title { font-size:14px; letter-spacing: 1px; margin:0 auto; text-align:center; flex:1; background: linear-gradient(45deg, #FFD700, #FFA500); -webkit-background-clip:text; -webkit-text-fill-color: transparent; background-clip: text; }
    .date-info { font-size: 10px; color: var(--teal); opacity: 0.9; }

    .wrap { position: fixed; left:50%; transform: translateX(-50%); top: var(--topbar-h); right:0; bottom:0; display:flex; align-items:center; justify-content:center; }
    canvas { background: transparent; image-rendering: pixelated; touch-action: none; }

    .hud { position: fixed; top: calc(var(--topbar-h) + 10px); left:50%; transform: translateX(-50%); z-index: 25; color: #7fffd4; background: rgba(0,0,0,0.35); padding: 6px 10px; border-radius: 10px; display:flex; gap:16px; font-size: 12px; text-shadow: 0 2px 6px rgba(0,0,0,0.6); }

    .overlay { position: fixed; inset: var(--topbar-h) 0 0 0; display:none; align-items:center; justify-content:center; flex-direction:column; background: radial-gradient(800px 400px at 50% 40%, rgba(0,0,0,0.6), rgba(0,0,0,0.9)); z-index: 30; text-align:center; padding: 24px; gap: 14px; }
    .overlay.show { display:flex; }
    .overlay h2 { margin:0; color: var(--gold); font-size: 18px; }
    .overlay p { margin:0; color:#d8f7ff; font-size: 12px; }
    .overlay .tap { color: var(--teal); font-size: 12px; opacity:0.95; }

    .touchbar { position: fixed; left:50%; transform: translateX(-50%); bottom: 14px; display:flex; gap:10px; z-index: 15; opacity: 0.98; }
    .lane-btn { width: 72px; height: 72px; border-radius: 12px; border:2px solid var(--gold); background: linear-gradient(145deg, rgba(95,158,160,0.22), rgba(0,0,0,0.5)); box-shadow: inset 0 4px 8px rgba(0,0,0,0.4), 0 6px 18px rgba(0,0,0,0.4); color:#fff; font-size: 12px; user-select:none; display:flex; align-items:center; justify-content:center; }
    .lane-btn.down { outline: 3px solid #7fffd4; }

    @media (max-width: 480px) { .back-btn { padding:6px 8px; font-size:11px; } .title { font-size:12px; } .hud { font-size:11px; gap:10px; padding:5px 8px; } .lane-btn { width:64px; height:64px; } }
  </style>
</head>
<body>
  <div class="topbar">
    <a class="back-btn" href="../../index.html">⟵ Back to Home</a>
    <div class="title">Starfall Rhythm<br><span class="date-info">Created: August 15, 2025</span></div>
    <a class="back-btn" href="../../leaderboard.html?gameId=starfall-rhythm">Leaderboard</a>
  </div>

  <div class="hud" id="hud">
    <span>Score: <span id="score">0</span></span>
    <span>Combo: <span id="combo">0</span></span>
    <span>Acc: <span id="acc">100%</span></span>
    <span>Time: <span id="time">0.0</span>s</span>
  </div>

  <div class="wrap">
    <canvas id="game"></canvas>
    <div class="overlay show" id="overlay">
      <h2>Catch the Falling Stars</h2>
      <p>Tap lanes as notes cross the hit line. Hold long notes to sustain.</p>
      <p class="tap">Tap to start · Keyboard: D F J K</p>
    </div>
  </div>

  <div class="touchbar" id="touchbar" aria-hidden="false">
    <div class="lane-btn" data-lane="0">D</div>
    <div class="lane-btn" data-lane="1">F</div>
    <div class="lane-btn" data-lane="2">J</div>
    <div class="lane-btn" data-lane="3">K</div>
  </div>

  <script>
    const GAME_ID = 'starfall-rhythm';
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const hudScore = document.getElementById('score');
    const hudCombo = document.getElementById('combo');
    const hudAcc = document.getElementById('acc');
    const hudTime = document.getElementById('time');

    // Layout
    let pixelRatio = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    let W = 0, H = 0, laneW = 0, lanes = 4;

    // Assets
    const Img = {};
    const assets = {
      tap: 'assets/starfall_note_tap.svg',
      hold: 'assets/starfall_note_hold.svg',
      ring: 'assets/starfall_hit_ring.svg'
    };
    function loadImg(src){ return new Promise((res, rej)=>{ const i = new Image(); i.onload = ()=>res(i); i.onerror = rej; i.src = src; }); }

    // Chart generation (60s song, ~120 BPM quarter notes, randomized lanes)
    const SONG_LEN = 60.0; // seconds
    const BPM = 120; // quarter notes per minute
    const BEAT = 60 / BPM; // seconds per beat
    const HIT_Y_RATIO = 0.84; // hit line position
    const SPEED = 1.8; // seconds from spawn to hit line

    // Timing windows (seconds)
    const WIN = { perfect: 0.06, great: 0.10, good: 0.16 };

    // Notes: { t: timeToHit, lane, type: 'tap'|'hold', len?: seconds, hit:false, judged:false, activeHold:false }
    const notes = [];

    function buildChart(){
      notes.length = 0;
      let t = 1.0; // lead-in
      const end = SONG_LEN - 2.0; // keep a small tail
      while (t < end) {
        // Structure: bars of 16th notes sometimes, sometimes quarters, sometimes holds
        const roll = Math.random();
        if (roll < 0.25) {
          // 1 bar of 16th burst
          for (let i=0;i<16;i++) {
            const lane = Math.floor(Math.random()*lanes);
            notes.push({ t: t + i*(BEAT/4), lane, type:'tap' });
          }
          t += 4*BEAT;
        } else if (roll < 0.65) {
          // steady quarters (4 beats)
          for (let i=0;i<4;i++) {
            const lane = Math.floor(Math.random()*lanes);
            notes.push({ t: t + i*BEAT, lane, type:'tap' });
          }
          t += 4*BEAT;
        } else {
          // holds and taps mixed over 2 beats
          for (let i=0;i<2;i++) {
            const lane = Math.floor(Math.random()*lanes);
            if (Math.random() < 0.55) {
              const len = (1 + Math.floor(Math.random()*3)) * BEAT; // 1-3 beats
              notes.push({ t: t + i*BEAT*2, lane, type:'hold', len });
            } else {
              notes.push({ t: t + i*BEAT*2, lane, type:'tap' });
            }
          }
          t += 2*BEAT*2;
        }
        t += BEAT * (Math.random() < 0.4 ? 0 : 0.5); // occasional syncopation
      }
      notes.sort((a,b)=>a.t-b.t);
    }

    // Game state
    let running = false, startedAt = 0, lastTs = 0, dt = 0, time = 0;
    let score = 0, combo = 0, total = 0, hits = 0;
    let gameOverHandled = false;

    // Input
    const keyToLane = { 'KeyD':0, 'KeyF':1, 'KeyJ':2, 'KeyK':3 };
    const laneDown = [false,false,false,false];

    function resize(){
      const availW = Math.min(window.innerWidth, 800);
      const top = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-h')) || 56;
      const availH = window.innerHeight - top - 100; // leave room for touchbar
      W = Math.floor(availW);
      H = Math.floor(Math.min(availH, 1000));
      laneW = Math.floor(W / lanes);
      canvas.style.width = W+'px'; canvas.style.height = H+'px';
      canvas.width = W * pixelRatio; canvas.height = H * pixelRatio;
      ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    }

    function yForNote(tHit){
      // position of a note at current time 'time'; reaches hit line at tHit
      const hitY = H * HIT_Y_RATIO;
      const tRemain = tHit - time; // seconds until hit
      const progress = 1 - (tRemain / SPEED); // 0 at spawn, 1 at hit
      return hitY * progress; // spawn from top
    }

    function drawBackground(){
      // Lanes
      ctx.clearRect(0,0,W,H);
      const hitY = H * HIT_Y_RATIO;
      for (let i=0;i<lanes;i++){
        const x = i*laneW;
        // lane body
        const grd = ctx.createLinearGradient(x,0,x+laneW,0);
        grd.addColorStop(0,'rgba(127,255,212,0.05)');
        grd.addColorStop(1,'rgba(0,225,255,0.05)');
        ctx.fillStyle = grd;
        ctx.fillRect(x+4, 0, laneW-8, H);
        // divider
        ctx.fillStyle = 'rgba(255,215,0,0.20)';
        if (i>0) ctx.fillRect(x, 0, 2, H);
      }
      // hit line
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(0, hitY-3, W, 6);
    }

    function drawNotes(){
      const hitY = H * HIT_Y_RATIO;
      for (const n of notes){
        // cull far past notes
        if (n.t + 1 < time) continue;
        const x = Math.floor(n.lane * laneW);
        if (n.type === 'tap'){
          const y = yForNote(n.t);
          if (y > -64 && y < H + 64) {
            const s = Math.min(64, laneW-12);
            ctx.drawImage(Img.tap, x + (laneW - s)/2, y - s/2, s, s);
          }
        } else { // hold
          const yHead = yForNote(n.t);
          const holdPixels = (n.len / SPEED) * (H * HIT_Y_RATIO); // proportional length
          const s = Math.min(56, laneW-14);
          // body (from head upward)
          ctx.drawImage(Img.hold, x + (laneW - s)/2, yHead - holdPixels, s, holdPixels + s/2);
          // head cap uses tap sprite for clarity
          ctx.drawImage(Img.tap, x + (laneW - s)/2, yHead - s/2, s, s);
        }
      }
      // pressed indicators
      for (let i=0;i<lanes;i++){
        if (laneDown[i]){
          const x = i*laneW;
          ctx.globalAlpha = 0.18; ctx.fillStyle = '#7fffd4';
          ctx.fillRect(x+4, 0, laneW-8, H);
          ctx.globalAlpha = 1;
        }
      }
    }

    function judgeFor(note){
      const d = Math.abs(time - note.t);
      if (d <= WIN.perfect) return 'perfect';
      if (d <= WIN.great) return 'great';
      if (d <= WIN.good) return 'good';
      return '';
    }

    function addHitEffect(lane){
      const x = lane*laneW + laneW/2;
      const y = H * HIT_Y_RATIO;
      const s = Math.min(96, laneW*0.9);
      try { ctx.drawImage(Img.ring, x - s/2, y - s/2, s, s); } catch {}
    }

    function tapLane(lane){
      laneDown[lane] = true;
      // find best candidate note in lane within GOOD window that is not yet judged
      let candidate = null, bestDelta = 9e9;
      for (const n of notes){
        if (n.lane !== lane) continue;
        if (n.judged) continue;
        const delta = Math.abs(time - n.t);
        if (n.type === 'hold'){
          // can start hold slightly early
          if (time < n.t - WIN.good || time > n.t + WIN.good) continue;
        } else {
          if (delta > WIN.good) continue;
        }
        if (delta < bestDelta){ bestDelta = delta; candidate = n; }
      }
      if (!candidate) return miss();
      const j = judgeFor(candidate);
      if (!j) return miss();
      addHitEffect(lane);
      if (candidate.type === 'hold'){
        // Start the hold; don't mark judged yet so update() can complete it
        candidate.activeHold = true;
        candidate.holdEnd = candidate.t + candidate.len;
      } else {
        // Tap note is fully judged on hit
        candidate.judged = true;
      }
      registerJudgement(j);
    }

    function releaseLane(lane){
      laneDown[lane] = false;
      // end holds if any
      for (const n of notes){
        if (n.activeHold && n.lane === lane){
          // release early penalizes
          if (time < n.holdEnd - WIN.good) {
            combo = 0;
            score = Math.max(0, score - 50);
          }
          n.activeHold = false; n.judged = true; // finalize
        }
      }
    }

    function registerJudgement(j){
      total++;
      if (j==='perfect'){ score += 100; combo++; hits++; }
      else if (j==='great'){ score += 70; combo++; hits += 0.7; }
      else if (j==='good'){ score += 40; combo = Math.max(0, combo); hits += 0.4; }
      updateHUD();
    }

    function miss(){
      total++;
      combo = 0;
      score = Math.max(0, score - 10);
      updateHUD();
    }

    function updateHUD(){
      hudScore.textContent = Math.floor(score);
      hudCombo.textContent = combo;
      const acc = total>0 ? Math.min(100, Math.max(0, (hits/total)*100)) : 100;
      hudAcc.textContent = (Math.round(acc*10)/10).toFixed(1) + '%';
      hudTime.textContent = time.toFixed(1);
    }

    function update(){
      // auto misses: any tap note passing good window without being judged
      for (const n of notes){
        if (n.judged) continue;
        if (n.type === 'tap' && time > n.t + WIN.good){ n.judged = true; miss(); }
        if (n.type === 'hold'){
          // if never started and window passed
          if (!n.activeHold && time > n.t + WIN.good){ n.judged = true; miss(); }
          // if holding, check auto-complete
          if (n.activeHold && time >= n.holdEnd){ n.activeHold = false; n.judged = true; score += 80; combo++; updateHUD(); }
        }
      }
      // finish when all notes judged or time exceeded
      if (time >= SONG_LEN || notes.every(n=>n.judged)){
        endGame();
      }
    }

    function draw(){
      drawBackground();
      drawNotes();
    }

    let rafId = 0;
    function loop(ts){
      if (!running) { rafId = requestAnimationFrame(loop); return; }
      dt = Math.min(0.033, (ts - lastTs)/1000 || 0.016); lastTs = ts;
      time = (performance.now() - startedAt) / 1000;
      update();
      draw();
      rafId = requestAnimationFrame(loop);
    }

    function start(){
      overlay.classList.remove('show');
      if (!Img.tap){
        const entries = Object.entries(assets);
        Promise.all(entries.map(([k,src])=>loadImg(src).then(i=>Img[k]=i))).then(()=>{
          go();
        });
      } else { go(); }
    }

    function go(){
      buildChart();
      running = true; startedAt = performance.now(); lastTs = performance.now(); time = 0; score=0; combo=0; total=0; hits=0; gameOverHandled=false;
      updateHUD(); resize();
    }

    function endGame(){
      running = false;
      overlay.querySelector('h2').textContent = 'Song Complete!';
      overlay.querySelector('p').textContent = 'Great job! Tap to play again.';
      overlay.classList.add('show');
      if (!gameOverHandled) { gameOverHandled = true; maybeSubmitLeaderboard().catch(console.error); }
    }

    async function maybeSubmitLeaderboard(){
      const finalScore = Math.floor(score);
      let dest = `../../leaderboard.html?gameId=${encodeURIComponent(GAME_ID)}`;
      try {
        const res = await fetch(`/api/leaderboard/rank?gameId=${encodeURIComponent(GAME_ID)}&score=${encodeURIComponent(finalScore)}`, {
          headers: { 'Accept': 'application/json' }
        });
        if (res.ok) {
          const data = await res.json();
          const rank = Number(data?.rank);
          const qualifies = Number.isFinite(rank) && rank > 0 && rank <= 20;
          if (qualifies) {
            let name = prompt(`New High Score! You placed #${rank}. Enter your name (max 20 chars):`, '');
            if (name != null) {
              name = name.trim().replace(/[^\w \-'.!]/g, '').slice(0, 20);
              if (name) {
                let submitted = false;
                try {
                  await fetch('/api/leaderboard/submit', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ gameId: GAME_ID, name, score: finalScore })
                  });
                  submitted = true;
                } catch {}
                if (submitted) dest += `&highlightRank=${encodeURIComponent(rank)}`;
              }
            }
          }
        }
      } catch (e) { console.error(e); }
      finally { location.href = dest; }
    }

    // Events
    overlay.addEventListener('click', start);
    overlay.addEventListener('touchstart', (e)=>{ e.preventDefault(); start(); }, {passive:false});

    window.addEventListener('resize', ()=>{ resize(); draw(); });
    resize(); requestAnimationFrame(loop);

    window.addEventListener('keydown', (e)=>{
      const lane = keyToLane[e.code];
      if (lane==null) return;
      if (!laneDown[lane]){ tapLane(lane); }
      laneDown[lane] = true;
      // touchbar visual sync
      const btn = document.querySelector(`.lane-btn[data-lane="${lane}"]`);
      if (btn) btn.classList.add('down');
    });
    window.addEventListener('keyup', (e)=>{
      const lane = keyToLane[e.code];
      if (lane==null) return;
      releaseLane(lane);
      const btn = document.querySelector(`.lane-btn[data-lane="${lane}"]`);
      if (btn) btn.classList.remove('down');
    });

    // Touch controls
    for (const el of document.querySelectorAll('.lane-btn')){
      el.addEventListener('touchstart', (e)=>{ e.preventDefault(); const lane = +el.dataset.lane; el.classList.add('down'); tapLane(lane); laneDown[lane]=true; }, {passive:false});
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); const lane = +el.dataset.lane; el.classList.remove('down'); releaseLane(lane); }, {passive:false});
      el.addEventListener('mousedown', ()=>{ const lane = +el.dataset.lane; el.classList.add('down'); tapLane(lane); laneDown[lane]=true; });
      el.addEventListener('mouseup', ()=>{ const lane = +el.dataset.lane; el.classList.remove('down'); releaseLane(lane); });
      el.addEventListener('mouseleave', ()=>{ const lane = +el.dataset.lane; el.classList.remove('down'); releaseLane(lane); });
    }
  </script>
</body>
</html>
