<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Hyperlane Hopper</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="icon" type="image/png" href="images/botbuiltarcade-icon-face.png">
  <style>
    :root {
      --gold: #FFD700;
      --teal: #5F9EA0;
      --ink: #0b0f12;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: radial-gradient(1200px 800px at 50% 10%, #112 0%, #090b10 45%, #05070a 100%);
      color: #F5F5DC;
      font-family: 'Press Start 2P', cursive;
      height: 100%;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .topbar {
      position: fixed;
      top: 0; left: 0; right: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 12px;
      background: rgba(0,0,0,0.45);
      border-bottom: 2px solid var(--gold);
      z-index: 10;
      backdrop-filter: blur(6px);
    }
    .back-btn {
      color: white;
      text-decoration: none;
      background: linear-gradient(45deg, var(--teal), #4682B4);
      border: 2px solid var(--gold);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      box-shadow: 0 4px 12px rgba(95,158,160,0.4);
    }
    .title {
      font-size: 14px;
      letter-spacing: 1px;
      background: linear-gradient(45deg, #FFD700, #FFA500);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 0 auto;
      text-align: center;
      flex: 1;
    }
    .date-info { font-size: 10px; color: var(--teal); opacity: 0.9; }

    .game-wrap {
      position: fixed;
      left: 50%; top: 54px; right: 0; bottom: 0;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: calc(100vh - 54px);
      z-index: 5;
    }
    canvas {
      background: transparent;
      image-rendering: pixelated;
      touch-action: none;
    }

    .hud {
      position: absolute; top: 66px; left: 50%; transform: translateX(-50%);
      color: var(--teal);
      text-shadow: 0 2px 6px rgba(0,0,0,0.6);
      font-size: 12px;
      z-index: 9;
      display: flex; gap: 16px;
      background: rgba(0,0,0,0.35);
      padding: 6px 10px;
      border-radius: 10px;
      pointer-events: none;
    }

    .controls {
      position: fixed;
      bottom: 18px; left: 50%; transform: translateX(-50%);
      display: grid;
      grid-template-columns: 64px 64px 64px;
      grid-template-rows: 64px 64px;
      gap: 10px;
      z-index: 11;
      opacity: 0.95;
    }
    .btn {
      width: 64px; height: 64px; border-radius: 14px;
      background: linear-gradient(145deg, rgba(95,158,160,0.25), rgba(0,0,0,0.5));
      border: 2px solid var(--gold);
      display: flex; align-items: center; justify-content: center;
      box-shadow: inset 0 4px 8px rgba(0,0,0,0.4), 0 6px 18px rgba(0,0,0,0.4);
      color: var(--gold);
      font-size: 20px;
      user-select: none;
    }
    .btn:active { transform: scale(0.98); }
    .btn.hidden { visibility: hidden; }

    .overlay {
      position: absolute; inset: 0; display: none; align-items: center; justify-content: center; flex-direction: column;
      background: radial-gradient(800px 400px at 50% 40%, rgba(0,0,0,0.6), rgba(0,0,0,0.9));
      z-index: 12; text-align: center; padding: 24px; gap: 14px;
    }
    .overlay.show { display: flex; }
    .overlay h2 { margin: 0; color: var(--gold); font-size: 18px; }
    .overlay p { margin: 0; color: #d8f7ff; font-size: 12px; }
    .overlay .tap { color: var(--teal); font-size: 12px; opacity: 0.95; }

    @media (min-width: 800px) {
      .controls { bottom: 24px; }
    }
  </style>
</head>
<body>
  <div class="topbar">
    <a class="back-btn" href="index.html">⟵ Back to Home</a>
    <div class="title">
      Hyperlane Hopper<br>
      <span class="date-info">Created: August 10, 2025</span>
    </div>
    <div style="width:96px"></div>
  </div>

  <div class="hud" id="hud"></div>

  <div class="game-wrap">
    <canvas id="game"></canvas>
    <div class="overlay" id="overlay">
      <h2>Hyperlane Hopper</h2>
      <p>Hop across hyperlanes of traffic and neon rivers. Reach all pads!</p>
      <p class="tap">Tap to start · Use ▲▼◀▶ — sideways hops help</p>
    </div>
  </div>

  <div class="controls" id="controls">
    <div class="btn hidden"></div>
    <div class="btn" data-dir="up">▲</div>
    <div class="btn hidden"></div>
    <div class="btn" data-dir="left">◀</div>
    <div class="btn" data-dir="down">▼</div>
    <div class="btn" data-dir="right">▶</div>
  </div>

  <script>
    // Canvas and sizing
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const hud = document.getElementById('hud');

    let COLS = 9; // grid columns
    let ROWS = 13; // grid rows
    let tile = 32; // computed later
    let pixelRatio = Math.max(1, Math.floor(window.devicePixelRatio || 1));

    const assets = {
      frog: 'images/hopper_frog.svg',
      carR: 'images/hopper_car_red.svg',
      carB: 'images/hopper_car_blue.svg',
      truck: 'images/hopper_truck.svg',
      log: 'images/hopper_log.svg',
      goal: 'images/hopper_goal_pad.svg',
      skull: 'images/hopper_skull.svg',
    };

    function loadImg(src) {
      return new Promise((res, rej) => { const i = new Image(); i.onload = () => res(i); i.onerror = rej; i.src = src; });
    }

    const Images = {};

    // Game state
    let running = false;
    let lives = 3;
    let score = 0;
    let level = 1;
    let timeLeft = 120; // seconds per level (doubled)
    let lastTime = 0;

    const START = { x: Math.floor(COLS/2), y: ROWS-1 };
    const player = { x: START.x, y: START.y, px: 0, py: 0, onLog: null };

    // Lanes configuration: from top (0) to bottom (ROWS-1)
    // 0: goals, 1-2: water, 3: safe, 4-6: road, 7: safe, 8-10: road, 11: safe, 12: start
    const goals = [false, false, false, false, false];

    // Entities
    let cars = []; // {x, yrow, speed, img, w, h, dir}
    let logs = []; // {x, yrow, speed, img, w, h, dir}
    let particles = [];
    let infoMsg = { text: '', time: 0 };

    // Compute evenly spaced goal columns across the grid (aligned to columns)
    function getGoalCols() {
      const n = goals.length;
      if (n <= 1) return [Math.round((COLS-1)/2)];
      const cols = [];
      for (let i=0; i<n; i++) {
        cols.push(Math.round(i * (COLS - 1) / (n - 1)));
      }
      return cols;
    }

    function rand(min, max) { return Math.random() * (max - min) + min; }

    // Per-level time budget (doubled baseline with gentler decay)
    function levelTime() {
      return Math.max(70, 120 - (level - 1) * 10);
    }

    // Simple neon particle VFX for crashes
    function spawnCrashVFX(cx, cy) {
      const n = 18;
      for (let i=0;i<n;i++) {
        const a = Math.random()*Math.PI*2;
        const sp = rand(80, 180);
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(a)*sp, vy: Math.sin(a)*sp,
          r: rand(2, 4), life: 0.6, color: i%2? '#FFD700' : '#ADFF2F'
        });
      }
    }

    function updateParticles(dt) {
      for (const p of particles) {
        p.x += p.vx*dt; p.y += p.vy*dt; p.life -= dt; p.r *= 0.98;
      }
      particles = particles.filter(p=>p.life>0);
    }

    function drawParticles() {
      if (!particles.length) return;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const p of particles) {
        ctx.globalAlpha = Math.max(0, Math.min(1, p.life/0.6));
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(0.1, p.r), 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function resetPlayer() {
      player.x = START.x; player.y = START.y; player.onLog = null; player.px = 0; player.py = 0;
    }

    function setupLevel() {
      cars = []; logs = [];
      // Road lanes: rows 10, 9, 8 and 6,5,4 (from bottom)
      spawnLaneCars(10, 1.1 + level*0.08, Images.carR, 2);
      spawnLaneCars(9, -1.4 - level*0.08, Images.truck, 2.5);
      spawnLaneCars(8, 1.25 + level*0.08, Images.carB, 2);

      spawnLaneCars(6, -0.95 - level*0.08, Images.carR, 2);
      spawnLaneCars(5, 1.5 + level*0.08, Images.truck, 2.5);
      spawnLaneCars(4, -1.2 - level*0.08, Images.carB, 2);

      // Water lanes: rows 2 and 1
      spawnLaneLogs(2, -0.75 - level*0.05, Images.log, 3);
      spawnLaneLogs(1, 0.85 + level*0.05, Images.log, 2.5);

      // reset timers
      timeLeft = levelTime();
      resetPlayer();
    }

    function spawnLaneCars(yrow, speed, img, scale) {
      const count = 4;
      const spacing = (COLS * tile) / count;
      const w = (img === Images.truck) ? tile*1.8 : tile*1.4;
      const h = tile*0.9;
      for (let i=0;i<count;i++) {
        cars.push({ x: i*spacing, yrow, speed, img, w, h, dir: Math.sign(speed) });
      }
    }

    function spawnLaneLogs(yrow, speed, img, scale) {
      const count = 3;
      const spacing = (COLS * tile) / count;
      const w = tile*2.2;
      const h = tile*0.9;
      for (let i=0;i<count;i++) {
        logs.push({ x: i*spacing, yrow, speed, img, w, h, dir: Math.sign(speed) });
      }
    }

    function resize() {
      const availW = Math.min(window.innerWidth, 720);
      const availH = window.innerHeight - 64; // reserve for topbar
      // portrait grid
      tile = Math.floor(Math.min(availW / COLS, availH / ROWS));
      const w = COLS * tile;
      const h = ROWS * tile;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = w * pixelRatio;
      canvas.height = h * pixelRatio;
      ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      // place HUD just above the goal row
      const tbH = (document.querySelector('.topbar') && document.querySelector('.topbar').offsetHeight) || 54;
      hud.style.top = (tbH + Math.round(tile * 0.1)) + 'px';
    }

    function drawBackground() {
      // Segments: goals, water, safe, road, safe, road, safe, start
      const w = COLS*tile;
      // Goals row
      ctx.fillStyle = 'rgba(166,255,0,0.08)';
      ctx.fillRect(0, 0, w, tile);
      // Water rows 1-2
      ctx.fillStyle = 'rgba(0,180,255,0.12)';
      ctx.fillRect(0, tile, w, tile*2);
      // Safe row 3
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fillRect(0, tile*3, w, tile);
      // Road rows 4-6
      ctx.fillStyle = 'rgba(255,0,90,0.06)';
      ctx.fillRect(0, tile*4, w, tile*3);
      // Safe row 7
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fillRect(0, tile*7, w, tile);
      // Road rows 8-10
      ctx.fillStyle = 'rgba(255,0,90,0.06)';
      ctx.fillRect(0, tile*8, w, tile*3);
      // Safe row 11
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fillRect(0, tile*11, w, tile);
      // Start row 12
      ctx.fillStyle = 'rgba(0,255,160,0.06)';
      ctx.fillRect(0, tile*12, w, tile);

      // Goal pads
      const padCols = getGoalCols();
      for (let i=0; i<padCols.length; i++) {
        const cx = padCols[i]*tile + tile/2; // pixel center for the pad
        const padSize = Math.floor(tile * 0.9);
        const yPad = Math.floor((tile - padSize) / 2);
        const img = Images.goal;
        ctx.drawImage(img, Math.floor(cx - padSize/2), yPad, padSize, padSize);
        if (goals[i]) {
          // draw a frog centered on the pad to indicate claimed
          const f = Math.floor(padSize * 0.7);
          ctx.drawImage(Images.frog, Math.floor(cx - f/2), yPad + Math.floor((padSize - f)/2), f, f);
        }
      }
    }

    function drawEntity(e) {
      const y = e.yrow * tile + (tile - e.h)/2;
      ctx.drawImage(e.img, e.x, y, e.w, e.h);
    }

    function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    function update(dt) {
      // Timers
      timeLeft -= dt;
      if (timeLeft <= 0) {
        infoMsg.text = 'TIME UP!';
        infoMsg.time = 1.6;
        loseLife();
        timeLeft = levelTime();
        return;
      }

      // Tick temporary message and particles
      if (infoMsg.time > 0) infoMsg.time -= dt;
      updateParticles(dt);

      // Move cars/logs
      const width = COLS*tile;
      cars.forEach(c => {
        c.x += c.speed * tile * dt;
        if (c.speed > 0 && c.x > width + 40) c.x = -c.w - rand(20, 100);
        if (c.speed < 0 && c.x < -c.w - 40) c.x = width + rand(20, 100);
      });
      logs.forEach(l => {
        l.x += l.speed * tile * dt;
        if (l.speed > 0 && l.x > width + 40) l.x = -l.w - rand(60, 120);
        if (l.speed < 0 && l.x < -l.w - 40) l.x = width + rand(60, 120);
      });

      // Collisions on road lanes (y 4-6 and 8-10)
      const px = player.x * tile + tile*0.2;
      const py = player.y * tile + tile*0.25;
      const pw = tile*0.6, ph = tile*0.6;

      if ((player.y >= 4 && player.y <= 6) || (player.y >= 8 && player.y <= 10)) {
        for (const c of cars) {
          if (c.yrow === player.y) {
            const cy = c.yrow*tile + (tile - c.h)/2;
            if (rectsOverlap(px, py, pw, ph, c.x, cy, c.w, c.h)) {
              // hit
              splashOrSmash(false);
              loseLife();
              return;
            }
          }
        }
      }

      // Water rows 1-2: must be on a log
      player.onLog = null;
      if (player.y >= 1 && player.y <= 2) {
        let onLog = false;
        for (const l of logs) {
          if (l.yrow === player.y) {
            const ly = l.yrow*tile + (tile - l.h)/2;
            if (rectsOverlap(px, py, pw, ph, l.x, ly, l.w, l.h)) {
              onLog = true; player.onLog = l; break;
            }
          }
        }
        if (!onLog) {
          splashOrSmash(true);
          loseLife();
          return;
        }
      }

      // If on log, carry the player
      if (player.onLog) {
        const shift = player.onLog.speed * dt;
        player.px += shift; // sub-tile shift
        // if drift pushes off screen -> fail
        const realX = (player.x + player.px) * tile;
        if (realX < -tile*0.2 || realX > COLS*tile - tile*0.8) {
          splashOrSmash(true);
          loseLife();
          return;
        }
        // convert fractional pos to grid when crossing tile
        if (Math.abs(player.px) >= 1) {
          const s = Math.sign(player.px);
          if (canMove(s, 0)) player.x += s;
          player.px -= s;
        }
      }

      // Goal reached
      if (player.y === 0) {
        // snap fractional drift to center the frog on the grid
        player.px = 0;
        const padCols = getGoalCols();
        const idx = padCols.indexOf(player.x);
        if (idx !== -1 && !goals[idx]) {
          goals[idx] = true;
          score += 1000 + Math.floor(timeLeft)*5;
          resetPlayer();
          if (goals.every(g=>g)) {
            level += 1;
            goals.fill(false);
            score += 2000;
            setupLevel();
          }
        } else {
          // not aligned to a pad column or pad already occupied -> back to start
          resetPlayer();
        }
      }
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width, canvas.height);
      drawBackground();
      // Draw cars and logs
      [...logs, ...cars].sort((a,b)=>a.yrow-b.yrow).forEach(drawEntity);
      // Particles on top of world
      drawParticles();
      // Draw player (centered in the grid cell)
      const fw = Math.floor(tile * 0.8);
      const fh = Math.floor(tile * 0.8);
      const px = Math.floor(player.x*tile + player.px*tile + (tile - fw)/2);
      const py = Math.floor(player.y*tile + (tile - fh)/2);
      ctx.drawImage(Images.frog, px, py, fw, fh);

      // HUD
      hud.textContent = `Level ${level}  |  Lives ${lives}  |  Score ${score}  |  Time ${Math.max(0, Math.ceil(timeLeft))}`;

      // Temporary info message (e.g., Time Up)
      if (infoMsg.time > 0) {
        const w = COLS*tile;
        const text = infoMsg.text;
        ctx.save();
        ctx.font = Math.floor(tile*0.45) + 'px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const alpha = Math.min(1, infoMsg.time / 1.0);
        ctx.globalAlpha = alpha;
        const tx = Math.floor(w/2), ty = Math.floor(tile*0.15);
        // backdrop
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fillRect(tx - 110, ty - 6, 220, Math.floor(tile*0.6));
        // text
        ctx.fillStyle = '#FFD700';
        ctx.fillText(text, tx, ty);
        ctx.restore();
      }
    }

    function gameLoop(ts) {
      if (!running) return;
      const dt = Math.min(0.05, (ts - lastTime) / 1000 || 0);
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    function loseLife() {
      lives -= 1;
      if (lives <= 0) {
        running = false;
        overlay.classList.add('show');
        overlay.querySelector('h2').textContent = 'Game Over';
        overlay.querySelector('.tap').textContent = 'Tap to restart';
      }
      resetPlayer();
    }

    function splashOrSmash(water) {
      // draw quick effect
      const x = player.x*tile + tile*0.5, y = player.y*tile + tile*0.5;
      const img = Images.skull;
      ctx.drawImage(img, x - tile*0.4, y - tile*0.4, tile*0.8, tile*0.8);
      if (!water) spawnCrashVFX(x, y);
    }

    function canMove(dx, dy) {
      const nx = player.x + dx;
      const ny = player.y + dy;
      return nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS;
    }

    function move(dx, dy) {
      if (!running) return;
      if (canMove(dx, dy)) {
        player.x += dx; player.y += dy; player.px = 0;
      }
    }

    // Input
    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (k === 'arrowup' || k === 'w') move(0,-1);
      else if (k === 'arrowdown' || k === 's') move(0,1);
      else if (k === 'arrowleft' || k === 'a') move(-1,0);
      else if (k === 'arrowright' || k === 'd') move(1,0);
    });

    // Touch controls
    document.querySelectorAll('.btn[data-dir]').forEach(btn => {
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const dir = btn.getAttribute('data-dir');
        if (dir==='up') move(0,-1);
        if (dir==='down') move(0,1);
        if (dir==='left') move(-1,0);
        if (dir==='right') move(1,0);
      }, {passive:false});
      btn.addEventListener('click', () => {
        const dir = btn.getAttribute('data-dir');
        if (dir==='up') move(0,-1);
        if (dir==='down') move(0,1);
        if (dir==='left') move(-1,0);
        if (dir==='right') move(1,0);
      });
    });

    // Overlay to start / restart
    function start() {
      score = 0; lives = 3; level = 1; goals.fill(false);
      setupLevel();
      overlay.classList.remove('show');
      lastTime = performance.now();
      running = true; requestAnimationFrame(gameLoop);
    }
    overlay.addEventListener('touchstart', (e)=>{ e.preventDefault(); start(); }, {passive:false});
    overlay.addEventListener('click', start);

    // Resize & load assets
    window.addEventListener('resize', () => { resize(); draw(); });

    Promise.all(Object.entries(assets).map(async ([k,src]) => { Images[k] = await loadImg(src); }))
      .then(() => { resize(); draw(); overlay.classList.add('show'); })
      .catch(() => { overlay.classList.add('show'); overlay.querySelector('p').textContent = 'Failed to load assets.'; });
  </script>
</body>
</html>
