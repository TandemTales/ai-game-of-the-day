<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tetris - AI Game of the Day</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            font-size: 18px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            font-size: 14px;
        }
        
        #backButton {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #ff6b6b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
            text-decoration: none;
            display: inline-block;
        }
        
        #backButton:hover {
            background-color: #ff5252;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 200;
            display: none;
        }
        
        #restartButton {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        
        #restartButton:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Level: <span id="level">1</span></div>
            <div>Lines: <span id="lines">0</span></div>
        </div>
        
        <div id="controls">
            <div>Controls:</div>
            <div>A/D - Move Left/Right</div>
            <div>S - Soft Drop</div>
            <div>W - Rotate</div>
            <div>Space - Hard Drop</div>
        </div>
        
        <a href="index.html" id="backButton">Back to Home</a>
        
        <div id="gameOver">
            <h2>Game Over!</h2>
            <div>Final Score: <span id="finalScore">0</span></div>
            <button id="restartButton">Play Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class Tetris3D {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000011);
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);

                // Game state
                this.board = [];
                this.boardWidth = 10;
                this.boardHeight = 20;
                this.currentPiece = null;
                this.score = 0;
                this.level = 1;
                this.lines = 0;
                this.dropTime = 0;
                this.dropInterval = 1000;
                this.gameRunning = true;

                // Initialize board
                for (let y = 0; y < this.boardHeight; y++) {
                    this.board[y] = [];
                    for (let x = 0; x < this.boardWidth; x++) {
                        this.board[y][x] = 0;
                    }
                }

                // Tetris pieces
                this.pieces = [
                    { // I piece
                        shape: [[1,1,1,1]],
                        color: 0x00ffff
                    },
                    { // O piece
                        shape: [[1,1],[1,1]],
                        color: 0xffff00
                    },
                    { // T piece
                        shape: [[0,1,0],[1,1,1]],
                        color: 0x800080
                    },
                    { // S piece
                        shape: [[0,1,1],[1,1,0]],
                        color: 0x00ff00
                    },
                    { // Z piece
                        shape: [[1,1,0],[0,1,1]],
                        color: 0xff0000
                    },
                    { // J piece
                        shape: [[1,0,0],[1,1,1]],
                        color: 0x0000ff
                    },
                    { // L piece
                        shape: [[0,0,1],[1,1,1]],
                        color: 0xffa500
                    }
                ];

                this.boardMeshes = [];
                this.currentPieceMeshes = [];

                this.init();
                this.setupControls();
                this.spawnPiece();
                this.animate();
            }

            init() {
                // Setup camera
                this.camera.position.set(0, this.boardHeight / 2, 15);
                this.camera.lookAt(0, this.boardHeight / 2, 0);

                // Add lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                this.scene.add(directionalLight);

                // Create board visualization
                this.createBoard();
            }

            createBoard() {
                // Board boundaries
                const geometry = new THREE.BoxGeometry(0.1, this.boardHeight, 0.1);
                const material = new THREE.MeshLambertMaterial({ color: 0x666666 });

                // Left wall
                const leftWall = new THREE.Mesh(geometry, material);
                leftWall.position.set(-this.boardWidth/2 - 0.5, this.boardHeight/2, 0);
                this.scene.add(leftWall);

                // Right wall
                const rightWall = new THREE.Mesh(geometry, material);
                rightWall.position.set(this.boardWidth/2 + 0.5, this.boardHeight/2, 0);
                this.scene.add(rightWall);

                // Bottom wall
                const bottomGeometry = new THREE.BoxGeometry(this.boardWidth + 1, 0.1, 0.1);
                const bottomWall = new THREE.Mesh(bottomGeometry, material);
                bottomWall.position.set(0, 0, 0);
                this.scene.add(bottomWall);

                // Initialize board meshes array
                for (let y = 0; y < this.boardHeight; y++) {
                    this.boardMeshes[y] = [];
                    for (let x = 0; x < this.boardWidth; x++) {
                        this.boardMeshes[y][x] = null;
                    }
                }
            }

            spawnPiece() {
                const pieceType = Math.floor(Math.random() * this.pieces.length);
                this.currentPiece = {
                    type: pieceType,
                    x: Math.floor(this.boardWidth / 2) - 1,
                    y: this.boardHeight - 1,
                    rotation: 0,
                    shape: this.pieces[pieceType].shape,
                    color: this.pieces[pieceType].color
                };

                // Check if game over
                if (this.checkCollision(this.currentPiece.x, this.currentPiece.y, this.currentPiece.shape)) {
                    this.gameOver();
                    return;
                }

                this.createPieceMeshes();
            }

            createPieceMeshes() {
                // Clear existing piece meshes
                this.currentPieceMeshes.forEach(mesh => this.scene.remove(mesh));
                this.currentPieceMeshes = [];

                const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                const material = new THREE.MeshLambertMaterial({ color: this.currentPiece.color });

                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x]) {
                            const mesh = new THREE.Mesh(geometry, material);
                            const worldX = this.currentPiece.x + x - this.boardWidth/2 + 0.5;
                            const worldY = this.currentPiece.y - y + 0.5;
                            mesh.position.set(worldX, worldY, 0);
                            this.scene.add(mesh);
                            this.currentPieceMeshes.push(mesh);
                        }
                    }
                }
            }

            checkCollision(x, y, shape) {
                for (let py = 0; py < shape.length; py++) {
                    for (let px = 0; px < shape[py].length; px++) {
                        if (shape[py][px]) {
                            const newX = x + px;
                            const newY = y - py;

                            if (newX < 0 || newX >= this.boardWidth || newY < 0) {
                                return true;
                            }

                            if (newY < this.boardHeight && this.board[newY][newX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            rotatePiece() {
                const rotated = this.currentPiece.shape[0].map((_, index) =>
                    this.currentPiece.shape.map(row => row[index]).reverse()
                );

                if (!this.checkCollision(this.currentPiece.x, this.currentPiece.y, rotated)) {
                    this.currentPiece.shape = rotated;
                    this.createPieceMeshes();
                }
            }

            movePiece(dx, dy) {
                if (!this.checkCollision(this.currentPiece.x + dx, this.currentPiece.y + dy, this.currentPiece.shape)) {
                    this.currentPiece.x += dx;
                    this.currentPiece.y += dy;
                    this.createPieceMeshes();
                    return true;
                }
                return false;
            }

            lockPiece() {
                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x]) {
                            const boardX = this.currentPiece.x + x;
                            const boardY = this.currentPiece.y - y;

                            if (boardY >= 0 && boardY < this.boardHeight) {
                                this.board[boardY][boardX] = this.currentPiece.color;

                                // Create permanent mesh
                                const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                                const material = new THREE.MeshLambertMaterial({ color: this.currentPiece.color });
                                const mesh = new THREE.Mesh(geometry, material);
                                const worldX = boardX - this.boardWidth/2 + 0.5;
                                const worldY = boardY + 0.5;
                                mesh.position.set(worldX, worldY, 0);
                                this.scene.add(mesh);
                                this.boardMeshes[boardY][boardX] = mesh;
                            }
                        }
                    }
                }

                // Clear current piece meshes
                this.currentPieceMeshes.forEach(mesh => this.scene.remove(mesh));
                this.currentPieceMeshes = [];

                this.clearLines();
                this.spawnPiece();
            }

            clearLines() {
                let linesCleared = 0;

                for (let y = 0; y < this.boardHeight; y++) {
                    let fullLine = true;
                    for (let x = 0; x < this.boardWidth; x++) {
                        if (!this.board[y][x]) {
                            fullLine = false;
                            break;
                        }
                    }

                    if (fullLine) {
                        // Remove meshes
                        for (let x = 0; x < this.boardWidth; x++) {
                            if (this.boardMeshes[y][x]) {
                                this.scene.remove(this.boardMeshes[y][x]);
                            }
                        }

                        // Move lines down
                        for (let moveY = y; moveY < this.boardHeight - 1; moveY++) {
                            for (let x = 0; x < this.boardWidth; x++) {
                                this.board[moveY][x] = this.board[moveY + 1][x];
                                this.boardMeshes[moveY][x] = this.boardMeshes[moveY + 1][x];
                                
                                if (this.boardMeshes[moveY][x]) {
                                    this.boardMeshes[moveY][x].position.y = moveY + 0.5;
                                }
                            }
                        }

                        // Clear top line
                        for (let x = 0; x < this.boardWidth; x++) {
                            this.board[this.boardHeight - 1][x] = 0;
                            this.boardMeshes[this.boardHeight - 1][x] = null;
                        }

                        linesCleared++;
                        y--; // Check this line again
                    }
                }

                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.score += linesCleared * 100 * this.level;
                    this.level = Math.floor(this.lines / 10) + 1;
                    this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);
                    this.updateUI();
                }
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('lines').textContent = this.lines;
            }

            gameOver() {
                this.gameRunning = false;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
            }

            restart() {
                // Clear board
                for (let y = 0; y < this.boardHeight; y++) {
                    for (let x = 0; x < this.boardWidth; x++) {
                        if (this.boardMeshes[y][x]) {
                            this.scene.remove(this.boardMeshes[y][x]);
                            this.boardMeshes[y][x] = null;
                        }
                        this.board[y][x] = 0;
                    }
                }

                // Clear current piece
                this.currentPieceMeshes.forEach(mesh => this.scene.remove(mesh));
                this.currentPieceMeshes = [];

                // Reset game state
                this.score = 0;
                this.level = 1;
                this.lines = 0;
                this.dropInterval = 1000;
                this.gameRunning = true;

                document.getElementById('gameOver').style.display = 'none';
                this.updateUI();
                this.spawnPiece();
            }

            setupControls() {
                document.addEventListener('keydown', (event) => {
                    if (!this.gameRunning) return;

                    switch(event.code) {
                        case 'KeyA':
                        case 'ArrowLeft':
                            this.movePiece(-1, 0);
                            break;
                        case 'KeyD':
                        case 'ArrowRight':
                            this.movePiece(1, 0);
                            break;
                        case 'KeyS':
                        case 'ArrowDown':
                            if (this.movePiece(0, -1)) {
                                this.score += 1;
                                this.updateUI();
                            }
                            break;
                        case 'KeyW':
                        case 'ArrowUp':
                            this.rotatePiece();
                            break;
                        case 'Space':
                            while (this.movePiece(0, -1)) {
                                this.score += 2;
                            }
                            this.updateUI();
                            break;
                    }
                });

                document.getElementById('restartButton').addEventListener('click', () => {
                    this.restart();
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (this.gameRunning) {
                    const currentTime = Date.now();
                    if (currentTime - this.dropTime > this.dropInterval) {
                        if (!this.movePiece(0, -1)) {
                            this.lockPiece();
                        }
                        this.dropTime = currentTime;
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (window.game) {
                window.game.camera.aspect = window.innerWidth / window.innerHeight;
                window.game.camera.updateProjectionMatrix();
                window.game.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Start the game
        window.game = new Tetris3D();
    </script>
</script>
</body>
</html>

